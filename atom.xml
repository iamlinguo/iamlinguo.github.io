<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iamLinGuo</title>
  
  <subtitle>以码为梦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iamlinguo.github.io/"/>
  <updated>2020-11-27T19:38:45.326Z</updated>
  <id>https://iamlinguo.github.io/</id>
  
  <author>
    <name>LinGuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Restful风格的接口设计</title>
    <link href="https://iamlinguo.github.io/2020/11/28/javaRestful/"/>
    <id>https://iamlinguo.github.io/2020/11/28/javaRestful/</id>
    <published>2020-11-27T19:11:30.023Z</published>
    <updated>2020-11-27T19:38:45.326Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>好好写接口，让前端少些抱怨</code></pre><hr><p>说到接口，不同的场景有不同的样式。<br>通常我们在接口设计中，很多接口都是/url/suburl/subdetails类似这样的格式，无限扩张接口拼接，其实这样很不美观，如果一个controller的接口过多，也不方便管理</p><h1 id="Restful接口"><a href="#Restful接口" class="headerlink" title="Restful接口"></a>Restful接口</h1><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>按照请求方式，我们常用的几种：<br>get：常用查询，获取列表或详情<br>post: 常用新增<br>put: 常用大幅度的数据修改<br>patch：局部的数据修改，比如禁用启用<br>delete: 常用删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/product"</span>,name=<span class="string">"商品接口"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">productController</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(path= <span class="string">""</span>,name=<span class="string">"商品列表"</span>)</span><br><span class="line"><span class="keyword">public</span> .. </span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">""</span> , name = <span class="string">"新增接口"</span>)</span><br><span class="line"><span class="keyword">public</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span>(path = <span class="string">""</span> , name = <span class="string">"修改接口"</span>)</span><br><span class="line"><span class="keyword">public</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping</span>(path = <span class="string">"/&#123;id&#125;"</span> , name = <span class="string">"删除接口"</span>)</span><br><span class="line"><span class="keyword">public</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一套CRUD的接口应该是如上所述的，并不需要过多的子url<br>如果接口中存在详细扩展，比如详情的查询或扩散的接口，有两种定义方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/product"</span>,name=<span class="string">"商品接口"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">productController</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/details"</span> , name = <span class="string">"详情接口"</span>)</span><br><span class="line"><span class="keyword">public</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">""</span> , name = <span class="string">"详情接口"</span> , params = <span class="string">"method = details"</span>)</span><br><span class="line"><span class="keyword">public</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果详情也有CRUD，一般情况下推荐使用第二种，否则使用url拼接即可    </p><h3 id="返回值定义"><a href="#返回值定义" class="headerlink" title="返回值定义"></a>返回值定义</h3><p>正常的做法，一般都是定义抽象类，封装响应码，响应信息，响应数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestResponse</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">Integer code ; <span class="comment">// 响应码</span></span><br><span class="line">String msg;  <span class="comment">//响应信息</span></span><br><span class="line">T data; <span class="comment">//响应数据  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分页数据封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageData</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">Integer total;</span><br><span class="line">List&lt;T&gt; rows; <span class="comment">//响应数据  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果分页响应的数据需要扩展，直接继承PageData。<br>如此一来，一套简洁完美的接口便定义好了。</p><p>其他的响应接口，比如javaweb，就可能随意一点了，看后台选什么模板把<br>再比如我们写小程序接口的时候，所有的请求形式都定义为了POST请求，响应格式也是<code>text/html; charset=UTF-8</code>，统一的做法都是封装一个HttpServletResponse的响应工具类<br>重写ContentType。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;好好写接口，让前端少些抱怨&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;说到接口，不同的场景有不同的样式。&lt;br&gt;通常我们在接口设计中，很多接口都是/url/suburl/subdetails类似这样的格式，无限扩张接口拼接，其实这样很不美观，如果一个
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://iamlinguo.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>好看的枚举</title>
    <link href="https://iamlinguo.github.io/2020/11/28/javaEnum/"/>
    <id>https://iamlinguo.github.io/2020/11/28/javaEnum/</id>
    <published>2020-11-27T18:43:59.445Z</published>
    <updated>2020-11-27T19:08:58.490Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>fuck,我连枚举都不会。</code></pre><hr><p>枚举使用的地方很多很多很多。重要的事说三遍。<br>举例：<br>以前我们在表中对数据做类型区分的时候，很多情况下都会使用1,2,3数字来区分代替，然后在代码中写一段if来区分，最后可能写的自己都忘记了，如果业务够复杂的话，基本上过<br>几天自己写的代码都想不起来什么意思了，除非你写了足够多的注释，不然真就隔三日对(代码)刮目相看。<br>我司之前的一个项目是外包出去的，一个线上商城，最近人手够了，我们也参与其中，大家开始纷纷吐槽，shit…这什么意思，谁来告诉我!这段代码谁看得懂，卧槽。类似这样的<br>话我听到不少，包括我过去写的代码也是这样让别人看不懂。<br>其实类似这样的场景可以使用枚举处理，举个栗子，服装有上衣、下装、鞋服配等几大类型，1=上衣，2=下装…依次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line"> sout(<span class="string">"衣服"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line"> sout(<span class="string">"鞋子"</span>)</span><br></pre></td></tr></table></figure><h3 id="优化一下上面的代码"><a href="#优化一下上面的代码" class="headerlink" title="优化一下上面的代码"></a>优化一下上面的代码</h3><p>首先我们定义表结构的时候使用字符串形式 – varchar<br>定义枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> clothesType&#123;</span><br><span class="line"></span><br><span class="line">JACKET(<span class="string">"上装"</span>),BOTTOMS(<span class="string">"下装"</span>),SHOES(<span class="string">"鞋子"</span>);  <span class="comment">//枚举值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> desc; <span class="comment">// 枚举描述 对应括号中的内容  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">clothesType</span><span class="params">(String desc)</span></span>&#123;   <span class="comment">//枚举的构造函数，我们使用枚举的时候，这个参数的值就是括号中的内容</span></span><br><span class="line"><span class="keyword">this</span>.desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举来判断  </span></span><br><span class="line"><span class="keyword">if</span>(clothesType.JACKET == type)</span><br><span class="line">sout(<span class="string">"衣服"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(clothesType.BOTTOMS == type)</span><br><span class="line">sout(<span class="string">"鞋子"</span>)</span><br></pre></td></tr></table></figure><p>这样的代码绝对能人别人一目了然，看得懂。</p><p>有小朋友开始问了，我从数据库中读取出来的是字符串啊！怎么比值啊？<br>我们再对枚举类做一些优化</p><pre><code class="java"><span class="keyword">public</span> <span class="keyword">enum</span> clothesType{    JACKET(<span class="string">"上装"</span>),BOTTOMS(<span class="string">"下装"</span>),SHOES(<span class="string">"鞋子"</span>);  <span class="comment">//枚举值</span>    <span class="keyword">private</span> <span class="keyword">final</span> desc; <span class="comment">// 枚举描述 对应括号中的内容  </span>    <span class="function"><span class="keyword">private</span> <span class="title">clothesType</span><span class="params">(String desc)</span></span>{   <span class="comment">//枚举的构造函数，我们使用枚举的时候，这个参数的值就是括号中的内容</span>        <span class="keyword">this</span>.desc = desc;    }    <span class="comment">// 通过枚举值即名称或描述来转换成枚举</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> clothesType <span class="title">parse</span><span class="params">(String nameOrDesc)</span></span>{        <span class="keyword">for</span>(clothesType item : clothesType.values()){  <span class="comment">//遍历所有的枚举值</span>            <span class="keyword">if</span>(item.desc.equals(nameOrDesc) || item.name().equals(nameOrDesc)){                <span class="keyword">return</span> item; <span class="comment">// 存在的枚举值返回</span>            }        }    }}<span class="comment">//使用枚举来判断  假设type是字符串 </span><span class="keyword">if</span>(clothesType.JACKET == clothesType.parse(type))    sout(<span class="string">"衣服"</span>);<span class="keyword">else</span> <span class="keyword">if</span>(clothesType.BOTTOMS == clothesType.parse(type))    sout(<span class="string">"鞋子"</span>)</code></pre><p>枚举是可以直接使用==来判断的哦。<br>同样括号中的值也可以有多个”,”分割，比如根据前缀或后缀匹配做枚举转换。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;fuck,我连枚举都不会。&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;枚举使用的地方很多很多很多。重要的事说三遍。&lt;br&gt;举例：&lt;br&gt;以前我们在表中对数据做类型区分的时候，很多情况下都会使用1,2,3数字来区分代替，然后在代码中写一段if来区分，最
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://iamlinguo.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式-springboot事务控制</title>
    <link href="https://iamlinguo.github.io/2020/11/28/distributed_springboot_2/"/>
    <id>https://iamlinguo.github.io/2020/11/28/distributed_springboot_2/</id>
    <published>2020-11-27T18:29:13.982Z</published>
    <updated>2020-11-27T18:32:21.843Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>让cv成为create</code></pre><hr><h1 id="springboot事务控制知识"><a href="#springboot事务控制知识" class="headerlink" title="springboot事务控制知识"></a>springboot事务控制知识</h1><p>保证数据的一致性，需要事务的控制。<br>spring的事务管理分为两种，编程式和声明式<br><code>@Transation</code>注解：<br>不仅可以注解在方法上，也可以直接在类，接口上，当注解在类上的时候意味着此类的所有public方法都是开启事务的，如果类和方法同时使用了事务注解，采用就近原则，<br>使用方法上的事务控制。 </p><h3 id="1-事务的隔离级别："><a href="#1-事务的隔离级别：" class="headerlink" title="1.事务的隔离级别："></a>1.事务的隔离级别：</h3><p>default：默认值，表示使用数据库的默认隔离级别，对大部分的数据库而言，通常就是read_committed<br>read_committed:该事务隔离级别表示一个事务只能读取另外一个事务已经提交的数据，可以防止脏读。<br>read_uncommited：该事务隔离级别表示一个事务可以读取另外一个事务已修改但没有提交的事务，该级别不能防止脏读和不可重复读<br>repeatable_read：该隔离级别表示一个事务在整个过程中可以多次重复查询，每次返回的记录都相同，即逝查询前有新增的数据满足查询，这些新增的数据也会被忽略，<br>该级别可以防止脏读和不可重复读、<br>serializable:所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该级别可以防止脏读，不可重复读和幻读。<br>注解的属性：isolation  </p><h3 id="2-事务的传播行为。"><a href="#2-事务的传播行为。" class="headerlink" title="2.事务的传播行为。"></a>2.事务的传播行为。</h3><p>required:如果当前存在事务，则加入事务，如果不存在，就创建一个新的事务。<br>supports:如果当前存在事务，则加入事务，如果不存在，以非事务的方式运行。<br>mandatory:如果当前存在事务，则加入事务，如果不存在，抛出异常。<br>requires_new:创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>not_supported:以非事务的方式运行，如果当前存在事务，则把当前事务挂起。<br>nerver:以非事务运行，如果当前存在事务，抛出异常<br>nested:如果当前存在事务，则创建一个事务作为当前的嵌套事务来处理，如果当前没有事务，和required一致。<br>注解的属性：propagation </p><p>timeout:事务的超时时间，默认值是-1，如果超过时间限制事务没有完成，自动回滚。<br>readonly:指定事务是否为只读事务，默认为false，为了忽略那些不需要事务的方法，比如读取数据，可以设置为read_only为true<br>rollkackfor:用于指定能够触发事务回滚的异常类型，可以指定多个异常<br>norollbackfor:指定那些异常不需要回滚<br>嵌套事务失效的场景：<br>在同一个类中，一个有事务的方法和一个没有事务的方法相互调用，都不会开启事务。<br>比如一个A方法标有注解B方法没有注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="comment">//a</span></span><br><span class="line">a()&#123;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b </span></span><br><span class="line"><span class="meta">@transaction</span></span><br><span class="line">b()&#123;</span><br><span class="line">  <span class="comment">//sql</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个没有注解的方法调用一个有事务注解的方法的时候，事务是不会生效的，原因：声明式事务采用的是cglib代理，而cglib代理的产生是继承原类，也就是说，我们在调用a方<br>法的时候，a没有开启事务，而a调用b的时候调的是原类的b方法，而不是代理之后的b方法，相反，如果b()调用a()，这样事务是生效的，因为b在代理中已经开启了事务，<br>在调用a()时，a也被事务管理了。<br>解决的方法：<br>两个方法拆分在不同的类中，这样b()的代理类会开启事务。不过要注意先后顺序，如果a()调用b()，那么b()是有事务的，而a()没有，因为在a()之后才开启的事务,反之。</p><p>声明式事务常见的一些坑：<br>1.在一个事务中，如果出现异常，很多情况下是不会回滚的，因为默认的事务规则是遇到runtimeException及其子类，和error错误才会回滚，如果想针对检测异常进行事务回滚，<br>需要用rollbackfor属性声明<br>2.在业务层捕捉异常后，发现事务不生效的情况，比如经常在service层对异常进行了try-catch处理后，这种情况下事务是不生效的，所以一般推荐的做法是在service层抛出异常<br>，所有的异常处理爱controller中处理，已保证事务对异常的捕捉。 </p><p>在springboot中使用。<br>在启动类上加上@EnableTransactionManagement  开始声明式事务 </p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;让cv成为create&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;springboot事务控制知识&quot;&gt;&lt;a href=&quot;#springboot事务控制知识&quot; class=&quot;headerlink&quot; title=&quot;springboot事务控制知
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://iamlinguo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式-springboot</title>
    <link href="https://iamlinguo.github.io/2020/11/28/distributed_springboot_1/"/>
    <id>https://iamlinguo.github.io/2020/11/28/distributed_springboot_1/</id>
    <published>2020-11-27T18:21:27.519Z</published>
    <updated>2020-11-27T18:30:15.557Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>让cv成为create</code></pre><hr><h1 id="springboot知识"><a href="#springboot知识" class="headerlink" title="springboot知识"></a>springboot知识</h1><p>创建一个springboot项目，使用maven打包构建工具，不再像ssm项目一样累赘，编写大量的配置文件，同时springboot内置了tomcat容器。<br>搭建好了第一个springboot项目之后，启动类上会有一个注解：<br>@SpringBootApplication<br>使用这个注解的前提是，启动类一定是在构建项目时的包下面，因为约束大于配置，这是使用maven必须承担的。<br>在@SpringBootApplication这个注解下还包含：<br>@ComponentScan：这是在SpringBoot中非常重要的一个注解，它会去扫描符合条件的包或者类(比如@Service、@Controller)，然后注入到容器中。<br>@EnableAutoConfigure:<br>这个注解是SpringBoot的自动装配，也就是加载第三方jar包到容器当中，在Springboot的启动过程中，会去spring-boot-autoconfigure.jar下面找到对应的<br>spring.factories文件，根据文件里面的键值对数据去查找对应的class文件，如果该类符合条件就注入到容器中，并且注入的这个类在依赖其他jar包的情况下，<br>依赖的jar包又有相应的依赖，都会被注入到容器当中，形成一条引用链。<br>tip:<br>这里说一下mybatis是如何抹掉xml文件的，在mybatis-springboot-autoconfigure这个jar包下面，有对应的mybatis的配置类MybatisProperties,这个类中包含了<br>我们xml文件当中对应的标签且被@ConfigurationProperties标识，所以每次springboot加载项目的时候会注入这个类，去根据属性名称寻找application.yml中对应的配置项。<br>springboot的默认配置文件只有:application.properties和application.yml。除此之外的都不是默认配置，不是默认配置文件需要用@PropertySource来加载。<br>另外，因为springboot帮我们配置了类似mybatis.xml文件，如果一定要使用自定义的文件就用@ImportResource加载自定义的配置类<br>配置类：</p><pre><code class="java"><span class="meta">@Configuration</span>   <span class="comment">//加上他之后这个类就是配置类</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>{    <span class="meta">@Bean</span><span class="comment">//加上它之后就相当于创建了一个&lt;bean&gt;&lt;/bean&gt;标签</span>    <span class="function"><span class="keyword">public</span> PetPo <span class="title">ppp</span><span class="params">()</span> </span>{<span class="comment">/*ppp相当于&lt;bean id="" class=""&gt;&lt;/bean&gt;中的id*/</span>        PetPo p=<span class="keyword">new</span> PetPo();        <span class="keyword">return</span> p;    <span class="comment">/*返回的结果类型就相当于&lt;bean id="" class=""&gt;&lt;/bean&gt;中的class*/</span>    }}</code></pre><p>springboot的多文件设置及切换<br>默认情况端口号下是读取默认的application.properties的，也叫主配置文件。<br>多个环境时，配置文件应为：<br>application-环境名.properties；<br>比如application-dev.properties;application-test.properties;<br>拿端口为例：<br>主配置文件：<br>server.port = 8080<br>application-dev.properties：<br>server.port = 8081<br>spring.profiles:dev //声明环境为开发<br>application-test.properties:<br>server.port = 8082<br>spring.profiles:test //声明环境为测试<br>这样就代表配置好了三个环境，如果需要将默认主环境切到开发环境：<br>spring.profiles.active=dev  //切换到开发环境的端口下  </p><p>如何动态的切换数据源：<br>1.右单击 -&gt;Run As-&gt;RunConfigurations-&gt;Arguments-&gt;在里面输入–spring.profiles.active=环境名<br>比如：–spring.profiles.active=dev<br>2.打成jar包，然后使用命令行运行<br>java -jar HelloWord-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev  </p><p>之前经常看到旁边的测试同志打包的时候都是通过这个命令切换配置文件</p><p>使用外部的配置文件：</p><ol><li>右单击 -&gt;Run As-&gt;RunConfigurations-&gt;Arguments-&gt;在里面输入–spring.config.location=路径名<br>比如：–spring.config.location=C:\Users\17732\Desktop\test\application.properties</li><li>java -jar HelloWord-0.0.1-SNAPSHOT.jar –spring.config.location=C:\Users\17732\Desktop\test\application.properties</li></ol><p>如果只是修改某一个配置，可以使用 –名称=value  –server.port=8888<br>需要注意的是，如果内部和外部有相同配置的时候，优先使用外部的。</p><h3 id="涨知识"><a href="#涨知识" class="headerlink" title="涨知识"></a>涨知识</h3><p>springboot的devtools.jar这个包有个有意思的地方，就是全局配置文件，这个在公司开发的时候用的非常多，在你的用户目录下加上一个.spring-boot-devtools.properties<br>，开发的时候所有的配置文件都可以放在里面，前提是引入了相关的jar包才行。 </p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;让cv成为create&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;springboot知识&quot;&gt;&lt;a href=&quot;#springboot知识&quot; class=&quot;headerlink&quot; title=&quot;springboot知识&quot;&gt;&lt;/a&gt;sprin
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://iamlinguo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka-集群搭建</title>
    <link href="https://iamlinguo.github.io/2020/11/28/kafkaGettinginstall/"/>
    <id>https://iamlinguo.github.io/2020/11/28/kafkaGettinginstall/</id>
    <published>2020-11-27T17:50:05.534Z</published>
    <updated>2020-11-27T18:19:03.676Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>海阔凭鱼跃，天高任鸟飞。</code></pre><hr><h1 id="安装的一些知识"><a href="#安装的一些知识" class="headerlink" title="安装的一些知识"></a>安装的一些知识</h1><ol><li>启动kafka集群的基础是依赖于zookeeper集群，通过zookeeper服务去连接，没有zk也就没有kafka集群，所以分布式中很多都是基于zk的。</li><li>必要的server.properties配置需要修改<br>broker.id= 0 or 1 or other  kafka集群区分 每个实例的区分，记得之前的zk也是按照一个id进行区分<br>zookeeper.connect = zookeeper注册地址 多个用,分割<br>listeners =  listener_name://host_name:port  kafka本机的地址<br>log.dirs = kafka的数据目录</li></ol><p>kafka启动在根目录下<br>常规启动: <code>bin/kafka-server-start.sh config/server.properties</code>    脚本+ kafka本机配置<br>这样启动的方式弊端在于，只要你退出进程就会关闭。<br>进程启动:  <code>nohup bin/kafka-server-start.sh config/server.properties &gt;/dev/null 2&gt;&amp;1 &amp;</code><br>其实就是后台启动，就像你挂QQ升级一样。<br>停止： <code>bin/kafka-server-stop.sh</code></p><h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><p>netstat 查看系统的网络状态<br>ctrl+c 退出当前程序<br>tail -f xx 实时查看日志文本</p><p>如果遇到集群启动失败，仔细检查防火墙、网络、配置文件、zk集群是否正常，作为一个新手，都是我走过的坑，所以有问题先看是否是其中。</p><p>聊聊我司对kafka的使用情况。<br>我目前只接触过一个场景，就是利用kafka的消息系统。<br>业务涉及内容：任务发起方，kafka消息，kafka消息处理。<br>在我司的任务调度系统中，使用的是xxl开源系统，定时执行任务脚本，将第三方数据读取到我司数据库或将本地数据做定时数据统计，生成业务表单发送到邮件或钉钉或直接写入<br>数据库做更新。<br>以钉钉告警为例：检查店员头像缺失告警<br>在xxlJob中实现任务，检测数据库中是否存在店员头像缺失，如果有缺失，将消息发送至钉钉告警群作提示。<br>任务定时每周凌晨执行，类似这样的场景还有很多很多，可能凌晨存在100个任务同时执行，但消费系统(推送到钉钉的单独服务)可能无法承受，这时我们引入kafka作为疏通管道，<br>每个任务跑完后将消息发送到kafka排队，等待消费系统挨个读取(消费系统可能由集群组成)，消费系统将kafka中的消息拉取后调用第三方接口推送消息。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;海阔凭鱼跃，天高任鸟飞。&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;安装的一些知识&quot;&gt;&lt;a href=&quot;#安装的一些知识&quot; class=&quot;headerlink&quot; title=&quot;安装的一些知识&quot;&gt;&lt;/a&gt;安装的一些知识&lt;/h1&gt;&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://iamlinguo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式-zookeeper[2]</title>
    <link href="https://iamlinguo.github.io/2020/11/28/distributed_zookeeper_2/"/>
    <id>https://iamlinguo.github.io/2020/11/28/distributed_zookeeper_2/</id>
    <published>2020-11-27T17:43:47.744Z</published>
    <updated>2020-11-27T17:48:34.304Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>前方是巨人</code></pre><hr><h1 id="zookeeper相关知识"><a href="#zookeeper相关知识" class="headerlink" title="zookeeper相关知识"></a>zookeeper相关知识</h1><h3 id="zoo-cfg-配置"><a href="#zoo-cfg-配置" class="headerlink" title="zoo.cfg 配置"></a>zoo.cfg 配置</h3><p>ticktime : 这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br>dataDir : 顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper的日志文件是在bin目录下，有一个zookeeper.out文件。<br>clientPort: 这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。伪集群模式下，这个端口需要配置成不同的。如果是多台虚拟机或者服务器下，则无需更改。<br>【server】的配置含义说明：<br>server.A=B:C:D<br>其中 A 是一个数字，表示这个是第几号服务器；<br>B 是这个服务器的 ip 地址；<br>C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；<br>D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p><p>如果是伪集群的配置方式（也就是在一台服务器上搭建多个ZK服务节点），由于 一台服务器下的IP地址肯定一样，所以不同的 Zookeeper 实例通信端口号不能一样，故需要给它们分配不同的端口号。<br>相反，如果是在不同的服务器下（不同的虚拟机，IP地址不同）搭建ZK的话，由于IP地址不同，则C与D对应的通信端口可以保持一致。当然也可以配置成其他的端口。</p><p>【注意点】：<br>其中的server.1里面的数字1，是我们在myid文件中指定的数值。代表不同的zk节点。<br>同时，IP地址配置也要与server.1所在的服务器节点的IP地址一致。<br>后面的2个通信端口，随意指定，只要不与其他端口冲突就行。</p><h1 id="涉及的一些linux命令"><a href="#涉及的一些linux命令" class="headerlink" title="涉及的一些linux命令"></a>涉及的一些linux命令</h1><ol><li>tar -zxvf xxx -C xx  解压到某个文件夹下面  </li><li>table键  快速拼写  </li><li>mv xx xx 重命名文件或文件夹  </li><li>service iptables stop  chkconfig iptables off  永久关闭防火墙<br>service iptables status   查看防火墙状态</li><li>yum install -y java-1.8.0-openjdk-devel.x86_64 快速安装jdk  </li><li>lsof -i:xx 查看被占用的端口</li><li>kill -9 $xx 杀死进程 </li></ol><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;前方是巨人&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;zookeeper相关知识&quot;&gt;&lt;a href=&quot;#zookeeper相关知识&quot; class=&quot;headerlink&quot; title=&quot;zookeeper相关知识&quot;&gt;&lt;/a&gt;zookeepe
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://iamlinguo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式-zookeeper[1]</title>
    <link href="https://iamlinguo.github.io/2020/11/28/distributed_zookeeper_1/"/>
    <id>https://iamlinguo.github.io/2020/11/28/distributed_zookeeper_1/</id>
    <published>2020-11-27T17:38:28.425Z</published>
    <updated>2020-11-27T17:43:30.497Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>打铁还需自身硬。</code></pre><hr><h1 id="zookeeper的理论知识"><a href="#zookeeper的理论知识" class="headerlink" title="zookeeper的理论知识"></a>zookeeper的理论知识</h1><p>随着发展，集中式演变到分布式，在分布式中存在一致性的问题，在分布式的模型下， 需要一个系统或组件来解决一致性的问题。–分布式协调组件–zookeeper  </p><h3 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper?"></a>什么是zookeeper?</h3><p>zookeeper是一个开放源码的分布式服务协调组件，高性能的一致性解决方案，将一些复杂的分布式一致性服务封装起来，构成一个可靠的原语集，提供简单的接口给用户使用。 </p><h3 id="提供了那些特性？"><a href="#提供了那些特性？" class="headerlink" title="提供了那些特性？"></a>提供了那些特性？</h3><ol><li>顺序一致性，客户端的更新顺序与他们发送的顺序一致</li><li>原子性，要么全成功要么失败</li><li>单一视图，无论客户端连接到哪一个服务器，都看到相同的zookeeper视图 </li><li>可靠性，一个更新操作完后，客户端再次更新之前，值不会改变 </li><li>实时性，特定的一段时间内，系统任何变更都会被客户端检测到。 </li></ol><h3 id="zookeeper的工作过程"><a href="#zookeeper的工作过程" class="headerlink" title="zookeeper的工作过程"></a>zookeeper的工作过程</h3><p>zookeeper集群启动后，会进行leader选举，其他的服务都是follower，并且和leader建立连接，用户数据同步和请求转发等。比如有请求落到follower机器上的时候，<br>follower机器会把请求转发给leader，由leader处理该请求，比如数据的写，在请求处理完之后再把数据同步到所有的follower  </p><h3 id="zookeeper和CAP的关系"><a href="#zookeeper和CAP的关系" class="headerlink" title="zookeeper和CAP的关系"></a>zookeeper和CAP的关系</h3><p>任何的分布式模型下，都是无法保证一致性，可用性，分区容错性的，只能保证其中两个，比如ACID就是保证了CA，不需要分区，著名的base理论也是保证了AP丢弃了C，<br>但是会保留最终一致性。zookeeper保证了CP丢弃了A，没有容错性也就谈不上分布式了，没有一致性，那后果也是很严重的，也是在极端情况下，当集群垮掉，<br>丢掉可用性，下次再请求。</p><h3 id="zookeeper中的角色"><a href="#zookeeper中的角色" class="headerlink" title="zookeeper中的角色"></a>zookeeper中的角色</h3><ol><li>leader: 负责进行投票的发起和决议，更新系统的状态，为客户端提供读和写的服务 </li><li>follower:用于接收客户端的请求并像客户端返回结果，参与leader选举，为客户端提供读的服务，</li><li>observer观察者，接收客户端连接，将写的请求转发给leader，但是不参与leader的选举，只同步leader的状态，observer是为了扩展系统，提高读取速度<br>客户端。  </li></ol><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;打铁还需自身硬。&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;zookeeper的理论知识&quot;&gt;&lt;a href=&quot;#zookeeper的理论知识&quot; class=&quot;headerlink&quot; title=&quot;zookeeper的理论知识&quot;&gt;&lt;/a&gt;zo
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://iamlinguo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式的一致性</title>
    <link href="https://iamlinguo.github.io/2020/11/28/distributed_2/"/>
    <id>https://iamlinguo.github.io/2020/11/28/distributed_2/</id>
    <published>2020-11-27T16:46:29.460Z</published>
    <updated>2020-11-27T17:35:24.591Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>千里之行，始于足下。</code></pre><hr><h1 id="一致性的重要性"><a href="#一致性的重要性" class="headerlink" title="一致性的重要性"></a>一致性的重要性</h1><p>分布式领域CAP理论告诉我们，任何一个分布式系统都无法同时满足一致性、可用性、分区容错性三个基本的需求。最多只能满足其中的两项，<br>但是一个分布式系统中，无论如何都无法彻底放弃一致性，如果放弃一致性，就说明这个系统中的数据不可信，数据也就没有意义了，无论如何，<br>分布式系统的一致性问题都需要关注。<br>tip:通常我们说的放弃一致性，是放弃强一致性，还是达到最终一致。</p><h1 id="数据的一致性"><a href="#数据的一致性" class="headerlink" title="数据的一致性"></a>数据的一致性</h1><p>数据一致性是数据库中的概念，简单的理解就是数据的正确性和完整性。<br>比如在集中式的服务下，我们可以通过事务或者锁对数据来保证，但是在分布式的环境下，多台服务的环境下就很难保证了，要保证多台服务器的<br>数据库读写到同一条数据很难，比如某个服务在写的过程中突然宕机，这也是分布式中必须面对的问题。 </p><h3 id="数据一致性的需求来源"><a href="#数据一致性的需求来源" class="headerlink" title="数据一致性的需求来源"></a>数据一致性的需求来源</h3><p>可用性，在数据复制到多台服务的过程中，可以消除单点故障，不会因为某个数据服务宕机导致服务无法正常运行。<br>性能，通过负载均衡技术，能够让分布在不同服务上的数据库对外提供服务，有效提高系统性能。<br>集中式和分布式的比较：<br>与集中式相比，分布式的性价比更高，处理任务的能力更强，可用性，扩展性也更好，当然了，分布式也存在一些问题，就是网络问题，无法沟通啥都不是，<br>随着分布式的服务越来越多的话，服务宕机的可能性也会越大，还有可能发生的最大的问题，就是数据处理时，一旦发生问题，数据就无法保证一致性，<br>但系统最重要的就是数据，插一段小话(数据时代，得数据者得天下)。</p><h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>理论：一个分布式系统只能同时满足一致性(Consistency)、可用性(Availability)、和分区容错性(Partition tolerance)三项中的两项。</p><h3 id="CAP的定义"><a href="#CAP的定义" class="headerlink" title="CAP的定义"></a>CAP的定义</h3><p>Consistency一致性<br>在进行数据的更新操作时，所有节点在同一时间的数据完全一致，一致性，就是数据一致性。<br>一致性可以从两个不同的角度看，一个是客户端，一个是服务端，从客户端看，主要指的是多并发访问时更新过的数据如何获取的问题，从服务端看，<br>则是更新如何复制分布到整个系统<br>一致性问题是因为并发，一定要主要考虑并发问题。</p><p>三种一致性策略：<br>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。<br>如果能容忍后续的部分或者全部访问不到，则是弱一致性。<br>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性<br>CAP中不可能同时满足的一致性指的是强一致性。</p><p>我的理解：<br>强一致性<br>在多个服务在调用同一张表时，比如A新增了一条数据，必须保证B查询的数据有A新增的数据<br>弱一致性<br>在多个服务在调用同一张表时，比如A新增了一条数据，不保证B读取到的就是A新增后的数据，在某个时间后可能读取到，可能由于一些网络原因或延迟问题，比如刷新一下又对了<br>最终一致性<br>系统最终返回上一次更新操作的值。不一致的窗口主要受通信延迟，系统负载影响，比如过节抢票，前一秒有票，点进去付款的时候提示你没有票了。</p><p>Availability可用性<br>服务一直可用，正常的响应时间。<br>对于一个可用性的分布式系统，每一个非故障节点必须对每一个请求作出响应，所以，我们一般在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><p>Partition Tolerance分区容错性<br>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 </p><p>前面说的分布式系统只能满足其二，可以百度一下CAP的证明。 </p><h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>理论： base指基本可用(Basically Available)、软状态(Soft State)、最终一致(Eventual Consistency)。</p><h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p> 在分布式的服务中，如果发生故障，可以丢失部分可用性，保证核心功能正常服务。</p><h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p> 在系统中存在中间状态，却又不影响整体可用。在分布式数据存储中，一般会有多个副本，允许他们延时一致性，就是软状态。</p><h3 id="最终一致"><a href="#最终一致" class="headerlink" title="最终一致"></a>最终一致</h3><p> 强一致性和弱一致性相反，最终一致是弱一致的特殊情况。  </p><p> ACID和BASE代表了两张截然不同的设计，ACID追求强一致性，BASE通过牺牲强一致获得可用。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;千里之行，始于足下。&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;一致性的重要性&quot;&gt;&lt;a href=&quot;#一致性的重要性&quot; class=&quot;headerlink&quot; title=&quot;一致性的重要性&quot;&gt;&lt;/a&gt;一致性的重要性&lt;/h1&gt;&lt;p&gt;分布式领域C
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://iamlinguo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>走进分布式</title>
    <link href="https://iamlinguo.github.io/2020/09/27/distributed_1/"/>
    <id>https://iamlinguo.github.io/2020/09/27/distributed_1/</id>
    <published>2020-09-26T18:55:50.071Z</published>
    <updated>2020-09-26T19:51:41.575Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>实话实说，这一段时间没怎么学习过，老毛病又犯了，生活嘛，总是有些小插曲，很正常，调整好自己的心态，然后重新出发，这就够了。这篇主要总结今天学的分布式内容，主要讲一下集中式和分布式部署的区别。</code></pre><hr><h1 id="走进分布式"><a href="#走进分布式" class="headerlink" title="走进分布式"></a>走进分布式</h1><h3 id="一、集中式部署"><a href="#一、集中式部署" class="headerlink" title="一、集中式部署"></a>一、集中式部署</h3><p>集中应该是最好理解的，因为我们在学校的时候应该大部分都在做这类的项目，项目写完后在自己的机器上面跑。<br>至少集中式的项目在现在很多企业也一直都在使用这种部署方式，比如企业，军队，像政府的一些项目，我今天就看到我一个朋友的CRM项目就是集中的，<br>当然了，不是一定要海量的数据，多并发才会要分布式，比如像多个项目的数据共享那肯定也要分布式处理了。<br>集中式系统最大的特点就是简单的，…能跑就行<br>集中式的一些缺点：<br>    1. 单机部署，无法承载项目的日益庞大<br>    2. 难维护，一次系统的宕机，凉凉<br>    3. 扩展性差</p><h3 id="二、分布式部署"><a href="#二、分布式部署" class="headerlink" title="二、分布式部署"></a>二、分布式部署</h3><p>分布式的定义：<br>    分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。<br>简单的讲，一个系统由多个独立的计算机提供服务，但是对于用户来说就像是一台计算机在运行一样，计算机越多，对于并发的处理，数据处理，<br>存储的性能来说也就大大提高了。分布式没有局限性，它通过网络进行连接，就算A计算机在中国B计算机在其他国家也不影响(扯淡，网络还是挺慢的哈哈哈哈)。<br>分布式的几个特征：<br>    1. 分布性：<br>        不受任何的环境因素，系统的多个计算机之间也没用主从这一说，每个独立的计算机都是同等的。<br>    2. 透明性：<br>        系统的资源共享，单独的一台计算机不仅可以使用本机的数据外，还可以使用整各分布式系统中各个计算机的数据。<br>    3. 同一性：<br>        同一个程序可以在不同的计算机上面并行执行，意思就是不同的计算机可以做相同的事<br>    4. 通信性：<br>        任意两台计算机可以沟通  </p><p>集中式和分布式的比较<br>与集中式相比，分布式的性价比更高，处理任务的能力更强，可用性，扩展性也更好，当然了，分布式也存在一些问题，就是网络问题，无法沟通啥都不是，<br>随着分布式的服务越来越多的话，服务宕机的可能性也会越大，还有可能发生的最大的问题，就是数据处理时，一旦发生问题，数据就无法保证一致性，但系统最重要的就是数据。</p><h3 id="三、分布式的常用场景及解决的问题"><a href="#三、分布式的常用场景及解决的问题" class="headerlink" title="三、分布式的常用场景及解决的问题"></a>三、分布式的常用场景及解决的问题</h3><pre><code>1. 分布式的应用和服务    应用和服务的分割，这样不仅可以提高并发能力，减少数据库的连接资源消耗，还能使多个应用复用共同的服务，扩展性。2. 分布式的静态资源处理     对网站的静态资源，如js css 图片资源，进行分布式可以减轻服务器的负载压力，提高访问速度 3. 分布式的数据存储     数据存储是最重要的，特别是一些海量数据，单机的内存空间大多数都是无法保证的（还记得以前有个老师跟我们说，它们公司每天加硬盘哈哈哈哈）4. 分布式的计算    一台计算机的处理能力慢的话，整体性能和体验肯定就差了，分布式可以在不同的计算机上处理同一个任务，最终整体的时间就降低了。</code></pre><h3 id="四、-分布式和集群这两个名词的区别"><a href="#四、-分布式和集群这两个名词的区别" class="headerlink" title="四、 分布式和集群这两个名词的区别"></a>四、 分布式和集群这两个名词的区别</h3><p>分布式：在多台不同的服务器上部署不同的服务模块<br>集群：在多台不同的服务器上部署相同的服务模块，比如一个请求过来，集群做负载均衡<br>分布式和集群的区别细细品。我举个例子就明白了<br>分布式：A计算机部署程序A，B计算机部署程序B，C计算机部署程序C<br>集群： A计算机部署程序A，B计算机部署程序A，C计算机部署程序B，D计算机部署程序C</p><p>学习来源：-[hollischuang]<a href="https://www.hollischuang.com/" target="_blank" rel="noopener">https://www.hollischuang.com/</a>  膜拜大佬</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;实话实说，这一段时间没怎么学习过，老毛病又犯了，生活嘛，总是有些小插曲，很正常，调整好自己的心态，然后重新出发，这就够了。
这篇主要总结今天学的分布式内容，主要讲一下集中式和分布式部署的区别。&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;走进
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://iamlinguo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8-Stream的使用</title>
    <link href="https://iamlinguo.github.io/2020/09/11/java8SEStream/"/>
    <id>https://iamlinguo.github.io/2020/09/11/java8SEStream/</id>
    <published>2020-09-10T17:56:37.343Z</published>
    <updated>2020-09-10T18:28:27.764Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-09-11 12:30。<br>每日总结</p><hr><h1 id="Stream（流）"><a href="#Stream（流）" class="headerlink" title="Stream（流）"></a>Stream（流）</h1><pre><code>jdk1.8的诞生，很多情况下都减少了我们编写的代码量，最重要的两个特性，第一个是函数式编程，第二个就是Stream。</code></pre><hr><h3 id="一、Stream是什么？"><a href="#一、Stream是什么？" class="headerlink" title="一、Stream是什么？"></a>一、Stream是什么？</h3><pre><code>Stream叫做流，像我们以前用的字节流、字符流，但和Stream本意是有天壤之别的，前者是我们所说的数据。数据按顺序排列组成的一段很长的有序字符串，抽象出来的一个名词，叫做流。而Stream虽然也是抽象，但更倾向于一个管道，一个处理数据的工具，数据经由它最后形成一个新的数据集合。</code></pre><h3 id="二、Stream用来干嘛？"><a href="#二、Stream用来干嘛？" class="headerlink" title="二、Stream用来干嘛？"></a>二、Stream用来干嘛？</h3><pre><code>Stream就是用来对集合来进行处理的，基本上我们对一个集合的操作都可以用它来完成。例如过滤，排序，分组，容器类型的转换甚至在某些业务场景下，由于查询的基数太大，条件查询速度太慢，都可以使用Stream，毕竟在数据库中处理肯定是没有在内存中处理快的。举例：用户表中有100000条数据表结构： user_id,name,age,parent_id转载用户的容器：List&lt;User&gt; users = new ArrayList&lt;&gt;();##### 1.查询age&gt;18的  SQL: select * from user where age &gt; 18users.size() == 70000;... 查询出来的70000条数据可能会结果一些业务处理，或者Bo，DTO的转换封装##### 2.在步骤1的基础上，将parent_id不存在的user_id去除在没有Stream的情况下，有什么好办法嘛，无非就是通过循环去判断，还有就是就是重新去查一遍数据 SQL: select * from user where  id in (select distinct(parent_id) from user where age &gt; 18 ) ;最终拿到结果users.size() == 50000这样做是非常不爽的，循环的效率太低，可能还要嵌套多个，左思右想怎么优化，用SQL重新查询一遍又太浪费，最终业务代码太复杂 。针对第二个的业务问题，这个时候Stream登场了，针对刚刚的操作分为两步解决##### 1. 得到所有parent_id  List&lt;Long&gt; parentIds = users.stream().map(item -&gt; item.getParentId).distinct().collect(Collectors.toList());##### 2. 判断user_id是否存在于parent_id，最后完成组装 users = user.stream().filter(item -&gt; parentIds.contains(item.getUserId)).collect(Collectors.toList());最后就拿到了处理后的50000数据 是不是感觉很清晰，代码也易读。</code></pre><h3 id="三、Stream详解："><a href="#三、Stream详解：" class="headerlink" title="三、Stream详解："></a>三、Stream详解：</h3><pre><code>Stream是一个接口，里面定义了很多方法，常见的有filter、map、sorted、collect等。`filter`:过滤    filter(对象名称自定义 -&gt; 过滤的内容(true\false)), 当值为true时，对象才能进入下一个方法执行    举例： 过滤age&gt;18 并且姓名不为空的用户     users = users.stream().filter(item -&gt; null != item.getName &amp;&amp;  item.getAge()&gt;18).collect(Collectors.toList());`map`:对当前操作对象进行重新定义      map(对象名称自定义 -&gt; 返回一个新的对象)    举例： 组装新的UserBo对象    List&lt;UserBo&gt; userBoss = users.stream().map(item -&gt; {    return new UserBo(item.userName,item.getAge(),item.getWeight());    }).collect(Collectors.toList());`sorted`:排序     sorted(比较器(Comparator))    举例：对users按年龄降序，如果一致则按体重升序    users.stream().sorted(Comparator.comparing(User::getAge).reversed().thenComparing(User::getWeight)).collect(Collectors.toList());`collect`:最终组装的结果    最终需要的结果多种多样，最常见的就是返回结果本身类型，但也有很多情况需要转为其他数据格式    举例：users按parent_id分组    Map&lt;Long,List&lt;User&gt;&gt; usersMap = users.stream().collect(Collectors.groupingBy(User::getParentId()));`distinct`：去重 `limit`：返回前n个元素</code></pre><p>Stream还提供了很多的方法，我对它的理解就是，跟我们SQL的where差不多了，你能想到的，基本上都可以用Stream实现</p><p>另外一些常用的例子，没仔细学习了，就几种写法。<br>    举例：去除users的重复用户名称<br>    users.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(User :: getUserName))), ArrayList::new));</p><p>有些复杂业务的情况下，通常都需要我们自定义方法去使用的，比如调用map进行对象组装时，可能里面掺杂了很复杂的业务，这时候最好是自己写一个额外的方法，在map中使用即可，其他方法同理，别问为什么，问就是函数式编程。</p><blockquote><p>总结：<br>Stream的三个操作步骤：<br>创建Stream&gt;中间操作(过滤排序组装)&gt;终止操作(结果集)<br>注意点：</p></blockquote><ol><li>自身不存储元素</li><li>不改变源数据</li><li>惰性执行(执行终止操作时才会依次执行中间操作)</li></ol><p>惰性，啊哈，结语：克服惰性，实现理想</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-09-11 12:30。&lt;br&gt;每日总结&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Stream（流）&quot;&gt;&lt;a href=&quot;#Stream（流）&quot; class=&quot;headerlink&quot; title=&quot;Stream（流）&quot;&gt;&lt;/a&gt;Stream（流）&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Java8" scheme="https://iamlinguo.github.io/categories/Java8/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-装饰模式</title>
    <link href="https://iamlinguo.github.io/2020/09/10/DecoratorPattern/"/>
    <id>https://iamlinguo.github.io/2020/09/10/DecoratorPattern/</id>
    <published>2020-09-09T18:02:37.182Z</published>
    <updated>2020-09-09T18:09:51.154Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-09-10 01:00。<br>今天要学的设计模式是：装饰模式</p><hr><h1 id="装饰-Decorator-模式"><a href="#装饰-Decorator-模式" class="headerlink" title="装饰(Decorator)模式"></a>装饰(Decorator)模式</h1><p>站在巨人的肩上，也不容易啊！<br>今天这个装饰者模式，废了不少脑筋，一度怀疑自己的iq多低，还好，想不通就慢慢想<br>时间多得是。 </p><hr><h3 id="什么是装饰者模式？"><a href="#什么是装饰者模式？" class="headerlink" title="什么是装饰者模式？"></a>什么是装饰者模式？</h3><p>对于刚刚学完的我，对它的理解是这样的，装饰者嘛，拿古代皇帝举一个例子，<br>皇帝的生活是什么样的，饭来张口衣来伸手，一招手便有太监知道皇帝要穿衣服了，佣人们<br>早已备好衣物，佣人1为皇上穿上带super的小裤衩，佣人2为皇上穿上了它最爱的带着超级女战士的小背心，经过一番梳妆打扮，皇上这才开始用膳。其实装饰者不然，就是对一个具体的对象<br>进行一些加工，不分先后顺序也不管他好看不好看的，你想如何装饰，全凭你的想象。<br>咳咳，书上是这么说的【动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活】，装饰者实际上就是对一个对象的引用进行传递，也不能叫传递把，大概意思就是<br>对原对象添加一个新职责后，将这个已经使用过的对象作为原对象。<br>拿穿衣服这个例子来说，我要给皇上穿背心，毛衣，毛衣+1，羽绒服，秋裤，破洞牛仔裤，<br>再套一个super裤衩，完美！<br>如果按照面向对象的特征去编写这样一个穿衣服的代码，是不是每件衣服或裤子都可能会被抽象成<br>一个类，需要穿什么的时候，给对应的对象增加（穿）上去，那你的代码一定会是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 对象：皇上</span><br><span class="line"> 皇上衣服：背心，毛衣，毛衣+<span class="number">1</span>，羽绒服</span><br><span class="line"> 皇上裤子：秋裤，破洞牛仔裤</span><br><span class="line"> 皇上裤子：没有</span><br><span class="line"> Emperor emp = <span class="keyword">new</span> Emperor();  <span class="comment">// 代指皇上这个对象</span></span><br><span class="line"> Clothes clo = <span class="keyword">new</span> Clothes(); <span class="comment">// 衣服类</span></span><br><span class="line"> erp.衣服 = erp.衣服 + clo .背心; <span class="comment">//给这个对象加衣服</span></span><br><span class="line"> <span class="comment">//雷同</span></span><br><span class="line">emp.show(); <span class="comment">// result = 给皇上穿上 ...;</span></span><br></pre></td></tr></table></figure><p>结构如图：<br><img src="/images/decorator.png" alt="avatar"><br>装饰模式，对这个问题有更好的解决方案，隐藏给这个对象穿衣服的细节，实现内部组装。<br>下面就用装饰模式来实现一遍：<br>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被装饰的对象   可扩展</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linguo</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">clothes</span><span class="params">()</span></span>;   <span class="comment">//穿衣服的方法  字符串拼接</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  这个类就是装饰模式的核心，也就是之前所说的：对一个具体对象实现穿衣服</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorClothes</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Person person;    <span class="comment">//被装饰对象 == 皇上</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鞋子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoesClothes</span> <span class="keyword">extends</span> <span class="title">DecoratorClothes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShoesClothes</span> <span class="params">(Person person)</span> </span>&#123;    <span class="comment">//对象的传递就靠它了</span></span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">clothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.person.clothes() + <span class="string">"穿上鞋子"</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 短袖</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TshirtClothes</span> <span class="keyword">extends</span> <span class="title">DecoratorClothes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TshirtClothes</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">clothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.person.clothes() + <span class="string">"穿上短袖"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他雷同</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 实例对象  之前说过的，Person可扩展，这里就直接穿衣服了</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">clothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;  <span class="comment">//啥都没穿，厉害！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person = <span class="keyword">new</span> TshirtClothes(<span class="keyword">new</span> ShoeClothes(person));</span><br><span class="line">String result= <span class="string">"皇上，"</span> + person.clothes();</span><br><span class="line">System.out.println(result);</span><br><span class="line"> 结果为：<span class="string">"皇上，穿上鞋子穿上短袖"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有什么不解的地方？我起初不解的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result= <span class="string">"皇上，"</span> + person.clothes();</span><br></pre></td></tr></table></figure><p>这段代码究竟是怎么执行的，您不妨打断点进去看一下，很奇妙的哦~<br>执行这段代码的时候，会回到最初的实例化，然后根据接口的实现去执行，就会先<br>执行ShoeClothes这个类的实现，然后再执行TshirtClothes类的实现，最终实现了结果的<br>拼接。<br>所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="keyword">new</span> TshirtClothes(<span class="keyword">new</span> ShoeClothes(person));</span><br></pre></td></tr></table></figure><p>这段代码实际执行该拆分为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="keyword">new</span> ShoeClothes(person)； == 穿上衣服</span><br><span class="line"><span class="comment">// 划重点： 原对象作为新对象传递 </span></span><br><span class="line">person =  <span class="keyword">new</span> TshirtClothes(person ); == 穿上衣服 + 穿上鞋子</span><br></pre></td></tr></table></figure><p>总之就是按实例化对象的顺序执行。</p><blockquote><p>总结：<br>装饰可以实现不分顺序，随意搭配。<br>比如给皇上穿上牛仔裤再穿秋裤套个super三角裤。</p></blockquote><p>我是Linguo，生命不息，奋斗不止。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-09-10 01:00。&lt;br&gt;今天要学的设计模式是：装饰模式&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;装饰-Decorator-模式&quot;&gt;&lt;a href=&quot;#装饰-Decorator-模式&quot; class=&quot;headerlink&quot; title=&quot;装饰(Dec
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>spring开发-配置文件</title>
    <link href="https://iamlinguo.github.io/2020/09/02/springConfig/"/>
    <id>https://iamlinguo.github.io/2020/09/02/springConfig/</id>
    <published>2020-09-02T14:49:52.912Z</published>
    <updated>2020-09-02T17:10:05.860Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-09-02 22:18。<br>近期工作总结</p><hr><h1 id="spring读取配置文件"><a href="#spring读取配置文件" class="headerlink" title="spring读取配置文件"></a>spring读取配置文件</h1><p>声明：<br>.properties文件本质上和.yml文件是没区别的，只不过是写法不同，所以我们在读取的时候也没区别，所以下面说到的.properties文件你可以理解为我也在说yml文件。<br>案例文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#邮箱配置</span><br><span class="line">spring.mail.host=smtp.xxx.com</span><br><span class="line">spring.mail.username=xxx1312222874@<span class="number">163</span>.com</span><br><span class="line">spring.mail.password=xxxxpassword</span><br><span class="line">spring.mail.port=<span class="number">465</span></span><br></pre></td></tr></table></figure><p>假设我们在项目中要读取以上配置并返回到对象当中。</p><h4 id="1-使用-ConfigurationProperties"><a href="#1-使用-ConfigurationProperties" class="headerlink" title="1. 使用@ConfigurationProperties"></a>1. 使用@ConfigurationProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.mail"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Long port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<br>注解：@ConfigurationProperties(prefix = “”, value = “”, ignoreInvalidFields = true, ignoreUnknownFields = true)<br><code>ConfigurationProperties</code>主要就是用来加载我们的配置文件的，这个注解由springBoot提供，也是用的最多的。<br><code>prefix</code>：配置文件的前缀<br><code>value</code>: 和prefix作用一样，不信你看源码,跟我们的RequestMapping的path\value一样，<code>@AliasFor</code>这个注解是Spring提供的，主要是在一个类中对两个方法互为别名，但又不冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"prefix"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br></pre></td></tr></table></figure><p><code>ignoreInvalidFields</code>：忽略读取到的字段，默认false，比如有些字段会存在类型转换错误，这个时候如果不忽略那启动就会报错，如果你设置了ignoreInvalidFields = true，那如果读取到了不匹配的类型会自动忽略，防止不必要的异常，一般情况下肯定都是false，因为谁也不敢保证自己的配置就是对的<br><code>ignoreUnknownFields</code>：同样也是忽略读取到的字段，默认为true，但和<code>ignoreInvalidFields</code>是有区别的，如果读取到的配置名称找不到对应的config类的属性，则忽略，同理。</p><blockquote><p>两个忽略属性最好的区分就是一个在类型上做文章，一个在名称上做文章<br>为什么要加上<code>@Component</code>注解呢？<code>@Component</code>我们都知道，就是注册组件，将这个类注册为bean，这样我们就可以直接用<code>@Autuwired</code>进行注入，如果不注册到spring容器当中是无法使用的，在注册的过程中将配置与属性绑定上去。类似的还可以使用spring的包扫描<br>还有一个小小的提示，就是不要用new对象方式注入config对象哦~</p></blockquote><h4 id="2-使用-ConfigurationProperties-EnableConfigurationProperties"><a href="#2-使用-ConfigurationProperties-EnableConfigurationProperties" class="headerlink" title="2. 使用@ConfigurationProperties + @EnableConfigurationProperties"></a>2. 使用@ConfigurationProperties + @EnableConfigurationProperties</h4><p>刚刚也说了，如果config类只使用了<code>@ConfigurationProperties</code>，没有使用spring的提供的凡是进行注册，那这样是不生效的。<br>要说<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>的关系，就是<code>@ConfigurationProperties</code>没有自己注册时，那便要用到<code>@EnableConfigurationProperties</code>来进行注册，<br>注解2：@EnableConfigurationProperties(value = {})，value是一个泛型类<br>前提条件，这两个注解在不同的类上面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 @ConfigurationProperties 注解的config类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"wiggen.uac.provider.dingtalk"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiestest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String appKey;</span><br><span class="line">  <span class="keyword">private</span> String appSecret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 @EnableConfigurationProperties 注解的config类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; ConfigurationPropertiestest<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="comment">//springBoot 入口类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这样看，你会觉得没有多大用处，但存在即合理。</p><h4 id="3-约束配置类"><a href="#3-约束配置类" class="headerlink" title="3. 约束配置类"></a>3. 约束配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mail"</span>, name = <span class="string">"enable"</span>, matchIfMissing = <span class="keyword">false</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//配置内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果spring.mail的enable为true时则TestConfiguration生效，反之。<br>注解3：@ConditionalOnProperty(prefix = “”, name = “”, matchIfMissing = , havingValue = “”)<br><code>havingValue</code>: 给定与配置的某个属性比较是否相等，如上面的就是将<code>havingValue</code>的值与spring.mail.enable=?进行比较，如果不匹配，那么整个配置类的内容不生效。<br><code>matchIfMissing</code>：默认为false,缺少name或value指定的属性时，配置类是否生效，比如设置enable没有找到，那么配置文件就不生效，比如配置文件中没有enable这个属性，就无法进行<code>havingValue</code>的值比较，这时候就看配置的<code>matchIfMissing</code>了。<br>@ConditionalOnProperty注解是依赖@Conditional的，@Conditional的作用是根据条件判断这个类是否允许注册到容器当中的，这个有时间可以自己去研究一下。</p><p>总结：<br>现在基本上都叫不到xml的配置了，以前的项目中可能会在resource中定义很多的xml文件，但维护起来会很不方便，如果把配置写成一个类，像业务一样去处理，不仅实现了代码与xml的解耦，也提升了代码的可读性，现在基本上都将配置放在一个独立的package下面，像Service、Controller一样，当然了，随着项目的进展，配置文件的内容肯定是不小的，这就需要我们来给配置文件一些规则了，合理洽淡的运用前缀以及各种分割词、注释，阅读起来其实也很方便。</p><p>学习素材来源：实际工作</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-09-02 22:18。&lt;br&gt;近期工作总结&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;spring读取配置文件&quot;&gt;&lt;a href=&quot;#spring读取配置文件&quot; class=&quot;headerlink&quot; title=&quot;spring读取配置文件&quot;&gt;&lt;/a&gt;spr
      
    
    </summary>
    
    
      <category term="春天系列" scheme="https://iamlinguo.github.io/categories/%E6%98%A5%E5%A4%A9%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka-入门</title>
    <link href="https://iamlinguo.github.io/2020/08/29/kafkaGettingStart/"/>
    <id>https://iamlinguo.github.io/2020/08/29/kafkaGettingStart/</id>
    <published>2020-08-28T20:28:08.679Z</published>
    <updated>2020-08-28T21:58:08.409Z</updated>
    
    <content type="html"><![CDATA[<p>北京时间：2020/08/29<br>近期技术总结</p><hr><p>在学习中间件之前，我觉得最大的一个问题就在于，我们不知道中间件到底用来干嘛，经过我这几个月的工作经验，我来告诉你，中间件大部分都是应用到开发端，也就是开发人员使用，很少会将中间件应用到客户端，比如，公司需要一个任务调度中心来处理一些复杂的业务、数据统计、定时任务时，可能就需要使用消息队列来处理任务，像比较流行的kafka、RocketMQ、RabbitMQ等这类消息队列中间件。当然了，中间件并不就是指这些，它更广泛的意思大概是，【是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件】(此处copy)，像我们熟知的tomcat、数据库都可以叫做中间件。今天主要讲的是消息队列中间件Kafka。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><blockquote><ol><li>消息队列的概念<br>消息队列，如果你了解栈的特性【先进后出】，那你对消息队列的理解应该是基本上掌握了，大同小异，<br>队列【先进先出】，其实道理就跟我们平常去银行排队是一个道理，取号排队，数字有序排列，假设银行大厅允许的最大排列范围是十个人，从1-10排满，第一个人走了，11号进来排队。<br>这个概念清楚了，那就没什么难度了，无非就是对框架的掌握程度，各个消息队列框架原理一致，思路与实现不同罢了。</li><li>Kafka入门<br>为什么选择Kafka?因为分布式。<br>kafka是一个开源的消息系统，分布式消息队列，kafka对消息保存时根据topic进行归类，发送消息者称为producer,消息接受者称为consumer,此外kafka集群有多个kafka实例组成，每个实例称为broker。无论是kafka集群，还是producer和consumer都依赖于zookeeper集群保存一些meta信息，来保存系统可用性。<br>看完这个， 你只需要明白几点：<ol><li>producer (生产者) 也就是往消息队列中放入数据的人</li><li>consumer (消费者) 从消息队列中取出数据的人</li><li>我们往一个kafka实例(单个kafka服务)中放入数据时，需要指定某个topic</li><li>分布式kafka时，zoopeeper集群是基础(可以自己尝试搭建zookeeper集群)。<br>同一个时间节点一个消费者组只能有一个消费者消费，并且消费者组中消费者消费的消息不会重复。<br>消费的是某个区，比如消费者2消费了topic1下面的partition0,那么这个组的消费者1不会再去消费topic1下面的partition0。<br>消费单元：partition(区)<br>producer写的时候，同一个分区队列是有序的，不同分区的消息是无序的。<br>分区与消费者组的关系<br>我们在往一个topic下加入消息时，是放入指定的分区下的，这是一个什么概念呢，其实就类似于给topic下的消息分类，默认最少会有一个分区，一般情况下是多个分区<br>如多个消息分区<br>partition0: data1 data2<br>partition1: data3 data4<br>partition1: data5 data6 data7<br>多个消费者<br>consumer1 consumer2 consumer3<br>kafka有自己的分组策略，与之对应的也就有相应的消费策略。<br>按照默认的策略，这个时候consumer1消费的就是data1 data2 data3，consumer2消费的就是data4 data5，consumer3消费的就是data6 data7。<br>补充：默认策略2，轮询消费策略<br>其实上述也就是 <code>一对一模式</code><br>消费者组是一个什么概念呢，其实就是多个consumer被分成了组 关键字:group<br>多个消费者<br>consumer1 consumer2 consumer3 consumer4<br>consumerGroup1:consumer1 consumer2<br>consumerGroup2:consumer3 consumer4<br>这种情况下，一个分区只允许一个消费者组的一个消费者去消费，意思就是，同一个消费者组消费一个分区时，只能消费一次，但不同的消费者组可以消费同一个分区。<br>比如上面的consumerGroup1去消费partition0时，只有consumer1去消费或者consumer2消费，不能同时消费，而partition0可以被consumerGroup1、consumerGroup2消费。也就是<code>一对多模式</code><br>加深一下印象，如下图：<br><img src="/images/queue.png" alt="avatar"></li></ol></li><li>总结<br>关键字：<br>broker：kafka实例，即Kafka服务<br>topic: 主题<br>partition: 分区<br>producer: 消息生产者<br>consumer: 消息消费者<br>Kafka支持的模式：<br>点对点模式(一对一)<br>发布/订阅者模式(一对多)</li></ol></blockquote><p>学习素材来源：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;北京时间：2020/08/29&lt;br&gt;近期技术总结&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在学习中间件之前，我觉得最大的一个问题就在于，我们不知道中间件到底用来干嘛，经过我这几个月的工作经验，我来告诉你，中间件大部分都是应用到开发端，也就是开发人员使用，很少会将中间件应用到客户端，比如，
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://iamlinguo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-设计原则</title>
    <link href="https://iamlinguo.github.io/2020/06/28/designPrinciples/"/>
    <id>https://iamlinguo.github.io/2020/06/28/designPrinciples/</id>
    <published>2020-06-27T18:39:01.375Z</published>
    <updated>2020-06-27T19:05:48.507Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-06-28 02:40。<br>今天要学的的内容是：设计原则</p><hr><h1 id="设计原则（principles）"><a href="#设计原则（principles）" class="headerlink" title="设计原则（principles）"></a>设计原则（principles）</h1><blockquote><ol><li>单一职能原则<br>定义： 就一个类而言，应该仅有一个引起它变化的原因。<br>浅出： 比如前面所说的，我们在一个类中定义了加减乘数四个方法，传入一个条件可以触发其中一个操作，这就是多职能，一个类做多种事情，显然不满足单一职能，<br>所以我们把四个操作分别封装成四个不同的操作类，每个类仅负责一件事。  </li><li>开放 - 封闭原则<br>定义： 软件实体（类，模块，方法等）应该可以扩展，但是不允许修改。<br>浅出： 在我们之前的加减乘除的在一个类中时，如果某一个需求需要变更，那么我们需要去修改其中的某个方法，所以我们用接口去定义公共的方法，供每个子类去<br>实现，这样加减乘除就负责加减乘除，如果有新的需求，就继续加一个类，不对原来的代码做修改，但在原来接口的基础上做扩展。 </li><li>依赖倒置（依赖倒转）原则<br>定义：<ol><li>高层模块不依赖于底层模块，两个都应该依赖抽象。</li><li>抽象不应该依赖细节，细节应该依赖于抽象（我们应该针对接口编程，而不要对实现编程）<br>浅出：比如接口设计，父级接口一依赖子级接口，它们都应该依赖于对象，也就是父接口和子接口本身不存在依赖关系，它们依赖的来源源自<br>对一个功能的抽象所形成。  像我们的集合框架，iterator 和 list 本身不存在依赖关系，对它们的定义是对业务的抽象。</li></ol></li><li>里氏代换原则<br>定义： 子类型必须能够替换掉它们的父类型<br>浅出： 在父子接口定义以及子类实现的时候，应该满足里氏代换原则，也就是子类继承了父类后，在可以直接引用父类的的公共属性及方法时，也要能够重写父类。</li></ol></blockquote><p>学习素材来源：《大话设计模式》–程杰</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-06-28 02:40。&lt;br&gt;今天要学的的内容是：设计原则&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;设计原则（principles）&quot;&gt;&lt;a href=&quot;#设计原则（principles）&quot; class=&quot;headerlink&quot; title=&quot;设计原则（
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-策略模式</title>
    <link href="https://iamlinguo.github.io/2020/06/21/strategyPattern/"/>
    <id>https://iamlinguo.github.io/2020/06/21/strategyPattern/</id>
    <published>2020-06-21T14:16:24.056Z</published>
    <updated>2020-06-21T15:42:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-06-21 22:18。<br>今天要学的设计模式是：策略模式</p><hr><h1 id="策略-Strategy-模式"><a href="#策略-Strategy-模式" class="headerlink" title="策略(Strategy)模式"></a>策略(Strategy)模式</h1><p>策略模式，从名字不难理解，策略，就像我们平常玩游戏的策略一样，策略1，策略2，在不同模式的时候我们选择不同的策略去使用，去完成任务。<br>业务场景：收银<br>    在商场中有，我们结算的时候，可能会有打折，然后满200减20，还有正常的收费等情况。<br>如果不使用设计模式，我们第一想到的肯定还是使用条件分支去判断它，然后去实现具体的计算方式，如果学了简单工厂，可能会想到使用简单工厂模式去封装条件<br>判断，然后根据不同的条件去调用不同的实现类。这种方式是可行的，但是我们要明确知道的一点是！简单工厂只为，仅为我们解决了创建对象的问题！如果后期各<br>种计算方式发生改变，那就要每次都去维护这个工厂。 在这种情况下，选择其他设计模式可能会更优<br>策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口</span></span><br><span class="line"><span class="comment"> * 接口：对功能进行抽象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linguo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>;  <span class="comment">//收银方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略：正常收费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 86131</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashNomal</span> <span class="keyword">implements</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务代码 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略：打折</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 86131</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRebate</span> <span class="keyword">implements</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把相同功能的不同的实现策略抽出一个借口供实现。<br>策略模式重要的一个点在于，它有一个上下文的管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口的上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 86131</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CashSuper cashSuper;  <span class="comment">// 不同的实现策略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(String type)</span></span>&#123;  <span class="comment">//结合简单工厂模式  </span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"正常收费"</span>:</span><br><span class="line"><span class="keyword">this</span>.cashSuper = <span class="keyword">new</span> CashNomal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"打折"</span>:</span><br><span class="line"><span class="keyword">this</span>.cashSuper = <span class="keyword">new</span> CashRebate();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略的计算结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cashSuper.acceptCash(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上下文初始化的时候，我们结合了简单工厂，根据不同的类型实例化不同的对象。<br>居然我们选择了策略模式，那就一定有它的优点<br>比较： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂  </span></span><br><span class="line">CashSuper cashSuper = CashFactory.create(<span class="string">"类型"</span>);</span><br><span class="line"><span class="comment">//策略模式</span></span><br><span class="line">CashContext cashContext = <span class="keyword">new</span> CashContext(<span class="string">"类型"</span>);</span><br></pre></td></tr></table></figure><p>你发现了什么，是不是我们使用简单工厂的时候我们看到了CashSuper和CashFactory，而使用策略模式时只用到了上下文对象CashContext。<br>这个点就非常重要了，这说明是用策略模式的耦合度更低了，连CashSuper这个父类都看不到了。<br>总结：  </p><blockquote><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种<br>算法类与使用算法类之间的耦合。<br>策略模式的Stategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。在所有策略中，我们得到的各个功能是？<br>getResult(),获得计算费用的结果。<br>策略模式封装了变化，我们在引用的时候不需要关注策略的实现，只需要使用上下文！</p></blockquote><p>学习素材来源：《大话设计模式》–程杰</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-06-21 22:18。&lt;br&gt;今天要学的设计模式是：策略模式&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;策略-Strategy-模式&quot;&gt;&lt;a href=&quot;#策略-Strategy-模式&quot; class=&quot;headerlink&quot; title=&quot;策略(Strat
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-简单工厂</title>
    <link href="https://iamlinguo.github.io/2020/06/11/simpleFactoryPattern/"/>
    <id>https://iamlinguo.github.io/2020/06/11/simpleFactoryPattern/</id>
    <published>2020-06-10T16:15:54.758Z</published>
    <updated>2020-06-10T16:30:48.041Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-06-10 22:30，今天星期三，哈哈最近在看的一部动漫“篮球少年王”更新了，我已经迫不及待了，先忍忍，容我写完这篇笔记。</p><p>简单的做一下今天工作的总结，早上出门下了点小雨，不过还好，因为！我带伞了哈哈哈哈，今天的工作内容主要还是改代码修代码，cto给我做的一个短信接口挑出了不少毛病，很多隐藏的bug，教我如何把代码抽离控制器实现业务层的封装，上午一直在做一个昨天没做完的图片接口，下午看了会同时刘哥写的代码，准备对接明天的任务。</p><p>最近在看“大话设计模式”这本书，今天的内容就写一下前几天看的内容把 </p><hr><h4 id="1-我为什么要学？"><a href="#1-我为什么要学？" class="headerlink" title="1. 我为什么要学？"></a>1. 我为什么要学？</h4><p>有没有一天，你突然觉得自己基础很差劲，在学校也没有好好学，工作也只会所谓的CV大法，看着复杂的项目不知从何下手，你是否听过一句话叫<code>“基础不牢，地动山摇“</code>。没错，这就是我，现在的我，从培训机构出来，感觉时间很快很匆忙就把一堆框架学完了，也写了很多代码，可还是对阅读代码、特别是开源代码库感到非常吃力，所以这也是我学习的决心，我要把没学过的东西都补回来。<br>可是每次下定决心打算学习一个知识点，三天打鱼两天晒网终究没学到什么东西，学了忘忘了学，反反复复总结：没学到啥jb。(废话好像有点多了…)<br>设计模式，我们任何一门语言好像都曾听闻过它的强大，它的好处，可我们一直停留在了对它的印象，其实不如静下心来好好学一学，相信一定收获颇丰。<br>设计模式从字面意思很好理解，设计！就这两个字足够你理解它，何为设计，设计不就是把一样不太完美的东西，经过你的一番修饰，让它变得完美。代码亦是如此，我们在工作中写了不知道多少冗余、复杂、流水代码，以至于隔三日定当不相识(????这tm是我写的代码黑人???三连)，想象一下，如果公司某个核心开源框架的底层是如此，那..后期可能会是一场灾难，这也是现在公司为什么不推崇faxxJson的一大原因(虽然易用，但bug居多，不宜长期打算，我不是黑粉！！)，设计模式我觉得最为重要的的一点莫过于这两点：<code>可复用、易读</code>。</p><h4 id="2-我学了设计模式能干嘛？"><a href="#2-我学了设计模式能干嘛？" class="headerlink" title="2. 我学了设计模式能干嘛？"></a>2. 我学了设计模式能干嘛？</h4><p>能干嘛？这tm还用想，刚刚不是说了嘛，基础差、看不懂！我不喜欢什么大道理，我就是看不懂(底子差)，我想先从设计模式入手，一步一步进阶。<br>我是一个有理想的码农，我希望某一天我也能写一款自己的开源项目给别人使用，讲实在的，能干嘛？举个例子，我现在每天写的代码，一个Method300+的代码，大量的if、else、for，在以前，我是没有意识去修改它的，项目嘛！能跑就行，有bug后期再改，其实这样是很不对的，天天CV上班摸鱼，三年下来还是老样子，更别提什么新技术新框架的掌握了，像这种大量的冗余代码的时候，大可仔细思考，那部分的代码可以抽出来形成单独的接口，在没看设计模式这本书之前，我是没有这种思想觉悟的，多学习积累经验嘛。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式这是我看的第一个设计模式，也是每一个想学习设计模式人的入门级知识，其实我目前也只学习了这一种哈哈哈哈。<br>请看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num1,num2,result; </span><br><span class="line">String symbol; <span class="comment">//符号</span></span><br><span class="line">System.out.println(<span class="string">"输入第一个数字"</span>);</span><br><span class="line">num1 = in.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入第二个数字"</span>);</span><br><span class="line">num1 = in.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入一个运算符"</span>);</span><br><span class="line">symbol = in.next(); </span><br><span class="line"><span class="keyword">if</span>(<span class="string">"+"</span>.equals(symbol))&#123;</span><br><span class="line">    result = num1 + num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(symbol))&#123;</span><br><span class="line">    result = num1 - num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(symbol))&#123;</span><br><span class="line">    result = num1 * num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(symbol))&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    result = num1 / num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看着是没有什么问题得把，如果实现了功能你是会去想如何扩展呢？还是直接push。</p><blockquote><p>Q1:  如果有1000种运算方法，怎么办？<br>    An: CV</p></blockquote><blockquote><p>Q2:  如果多个业务需要调用其中一个方法，怎么办？<br>    An: again</p></blockquote><p>问题还有很多，这两个可能是我们可能听闻过的，其实很简单，请看以下分解：<br>num1,num2,result;这三个变量实际上是固定的，所以我们把它封装到一个对象里面： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="comment">//计算需要的数值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> Number1;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> Number2;</span><br><span class="line"><span class="comment">// get set方法 </span></span><br><span class="line"><span class="comment">//返回结果的方法  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们是否可以把每个操作看做一个对象，比如加法，这个对象只做只做加法运算，减法只做减法运算,运算的对象来自哪？就是我们刚刚定义的<code>Operation</code>对象。<br>比如把加减乘除运算符拆分成四个对象，并且继承自需要运算的对象： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getNumber1() + <span class="keyword">super</span>.getNumber2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getNumber1() * <span class="keyword">super</span>.getNumber2(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他操作雷同</span></span><br></pre></td></tr></table></figure><p>重点来了！<br>什么是工厂，我第一意识就是想到了打工的工厂，不同的环节形成了工厂的流水线作业，假如我在一家做饼的工厂的新人，我负责的工作是和面粉，同事1负责的是烧饼，同事2负责的是打包。当我每天上班走到我的岗位的时候，经过了同事2打包的地方，我继续走，因为这不是我的岗位，经过同事1的时候，发现还不是，知道走到二楼，我才找到了我的岗位位置，开始一天的工作。(我实在想不出什么好的例子了)，我们的工厂模式其实也差不多：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operationType)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"+"</span>.equals(operationType))&#123;  <span class="comment">//同事2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(operationType))&#123;  <span class="comment">//同事1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(operationType))&#123;  <span class="comment">//我</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(operationType))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现一个特点，就是这个工厂对象里面包含了所有我需要的运算对象，我想要进行某一个运算的时候，直接去这个对象中拿就行了(就像我和我的同事们都被限制在这家工厂中)，当然需要给定你的条件(operationType)</p><p>今天的笔记就到这里。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-06-10 22:30，今天星期三，哈哈最近在看的一部动漫“篮球少年王”更新了，我已经迫不及待了，先忍忍，容我写完这篇笔记。&lt;/p&gt;
&lt;p&gt;简单的做一下今天工作的总结，早上出门下了点小雨，不过还好，因为！我带伞了哈哈哈哈，今天的工作内容主要还是改代码
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>我拥有自己的blog了！</title>
    <link href="https://iamlinguo.github.io/2020/06/04/myblog/"/>
    <id>https://iamlinguo.github.io/2020/06/04/myblog/</id>
    <published>2020-06-03T18:31:43.518Z</published>
    <updated>2020-06-07T15:18:27.116Z</updated>
    
    <content type="html"><![CDATA[<p>其实之前自己写过一个blog,但是感觉不太好用，所以chrome了一下，发现很多人都在用这个HEXO的静态博客，效果还不错，<br>刚好解决了我的燃眉之急，让我快速短时间的有一个总结的地方，顺便做做技术分享。<br>我一直讲的一句话就是，“生活需要仪式感”。<br>学习，亦是如此<br>所以此时此刻此景，我要开启属于我的生涯，我的技术生涯，我的职场生涯，去追求我所热爱的东西<br>2020-06-07<br>地点：魔都<br>加油吧，少年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实之前自己写过一个blog,但是感觉不太好用，所以chrome了一下，发现很多人都在用这个HEXO的静态博客，效果还不错，&lt;br&gt;刚好解决了我的燃眉之急，让我快速短时间的有一个总结的地方，顺便做做技术分享。&lt;br&gt;我一直讲的一句话就是，“生活需要仪式感”。&lt;br&gt;学习，亦
      
    
    </summary>
    
    
    
      <category term="初衷" scheme="https://iamlinguo.github.io/tags/%E5%88%9D%E8%A1%B7/"/>
    
  </entry>
  
</feed>
