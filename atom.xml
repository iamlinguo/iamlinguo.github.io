<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iamLinGuo</title>
  
  <subtitle>以码为梦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iamlinguo.github.io/"/>
  <updated>2020-09-10T18:16:32.931Z</updated>
  <id>https://iamlinguo.github.io/</id>
  
  <author>
    <name>LinGuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8-Stream的使用</title>
    <link href="https://iamlinguo.github.io/2020/09/11/java8SEStream/"/>
    <id>https://iamlinguo.github.io/2020/09/11/java8SEStream/</id>
    <published>2020-09-10T17:56:37.343Z</published>
    <updated>2020-09-10T18:16:32.931Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-09-11 12:30。<br>每日总结</p><hr><h1 id="Stream（流）"><a href="#Stream（流）" class="headerlink" title="Stream（流）"></a>Stream（流）</h1><pre><code>jdk1.8的诞生，很多情况下都减少了我们编写的代码量，最重要的两个特性，第一个是函数式编程，第二个就是Stream。</code></pre><hr><h3 id="一、Stream是什么？"><a href="#一、Stream是什么？" class="headerlink" title="一、Stream是什么？"></a>一、Stream是什么？</h3><pre><code>Stream叫做流，像我们以前用的字节流、字符流，但和Stream本意是有天壤之别的，前者是我们所说的数据，数据按顺序排列组成的一段很长的有序字符串，抽象出来的一个名词，叫做流，而Stream虽然也是抽象，但更倾向于一个管道，一个处理数据的工具，数据经由它最后形成一个新的数据集合。</code></pre><h3 id="二、Stream用来干嘛？"><a href="#二、Stream用来干嘛？" class="headerlink" title="二、Stream用来干嘛？"></a>二、Stream用来干嘛？</h3><pre><code>Stream就是用来对集合来进行处理的，基本上我们对一个集合的操作都可以用它来完成，例如过滤，排序，分组，容器类型的转换，甚至在某些业务场景下，由于查询的基数太大，条件查询速度太慢，都可以使用Stream，毕竟在数据库中处理肯定是没有在内存中处理快的。举例：用户表中有100000条数据表结构： user_id,name,age,parent_id转载用户的容器：List&lt;User&gt; users = new ArrayList&lt;&gt;();##### 1.查询age&gt;18的  SQL: select * from user where age &gt; 18users.size() ===== 70000;... 查询出来的70000条数据可能会结果一些业务处理，或者Bo，DTO的转换封装##### 2.在步骤1的基础上，将parent_id不存在的user_id去除在没有Stream的情况下，有什么好办法嘛，无非就是通过循环去判断，还有就是就是重新去查一遍数据 SQL: select * from user where  id in (select distinct(parent_id) from user where age &gt; 18 ) ;最终拿到结果users.size() ===== 50000这样做是非常不爽的，循环的效率太低，可能还要嵌套多个，左思右想怎么优化，用SQL重新查询一遍又太浪费，最终业务代码太复杂 。针对第二个的业务问题，这个时候Stream登场了，针对刚刚的操作分为两步解决##### 1. 得到所有parent_id  List&lt;Long&gt; parentIds = users.stream().map(item -&gt; item.getParentId).distinct().collect(Collectors.toList());##### 2. 判断user_id是否存在于parent_id，最后完成组装 users = user.stream().filter(item -&gt; parentIds.contains(item.getUserId)).collect(Collectors.toList());最后就拿到了处理后的50000数据 是不是感觉很清晰，代码也易读。</code></pre><h3 id="三、Stream详解："><a href="#三、Stream详解：" class="headerlink" title="三、Stream详解："></a>三、Stream详解：</h3><pre><code>Stream是一个接口，里面定义了很多方法，常见的有filter、map、sorted、collect等。`filter`:过滤    filter(对象名称自定义 -&gt; 过滤的内容(true\false)), 当值为true时，对象才能进入下一个方法执行    举例： 过滤age&gt;18 并且姓名不为空的用户     users = users.stream().filter(item -&gt; null != item.getName &amp;&amp;  item.getAge()&gt;18).collect(Collectors.toList());`map`:对当前操作对象进行重新定义      map(对象名称自定义 -&gt; 返回一个新的对象)    举例： 组装新的UserBo对象    List&lt;UserBo&gt; userBoss = users.stream().map(item -&gt; {    return new UserBo(item.userName,item.getAge(),item.getWeight());    }).collect(Collectors.toList());`sorted`:排序     sorted(比较器(Comparator))    举例：对users按年龄降序，如果一致则按体重升序    users.stream().sorted(Comparator.comparing(User::getAge).reversed().thenComparing(User::getWeight)).collect(Collectors.toList());`collect`:最终组装的结果    最终需要的结果多种多样，最常见的就是返回结果本身类型，但也有很多情况需要转为其他数据格式    举例：users按parent_id分组    Map&lt;Long,List&lt;User&gt;&gt; usersMap = users.stream().collect(Collectors.groupingBy(User::getParentId()));`distinct`：去重 `limit`：返回前n个元素</code></pre><p>Stream还提供了很多的方法，我对它的理解就是，跟我们SQL的where差不多了，你能想到的，基本上都可以用Stream实现。</p><p>另外一些常用的例子，没仔细学习了，就几种写法。<br>    举例：去除users的重复用户名称<br>    users.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(User :: getUserName))), ArrayList::new));</p><p>有些复杂业务的情况下，通常都需要我们自定义方法去使用的，比如调用map进行对象组装时，可能里面掺杂了很复杂的业务，这时候最好是自己写一个额外的方法，在map中使用即可，其他方法同理，别问为什么，问就是函数式编程。</p><blockquote><p>总结：<br>Stream的三个操作步骤：<br>创建Stream&gt;中间操作(过滤排序组装)&gt;终止操作(结果集)</p></blockquote><p>注意点：</p><ol><li>自身不存储元素</li><li>不改变源数据</li><li>惰性执行(执行终止操作时才会依次执行中间操作)</li></ol><p>惰性，啊哈，结语：克服惰性，实现理想</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-09-11 12:30。&lt;br&gt;每日总结&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Stream（流）&quot;&gt;&lt;a href=&quot;#Stream（流）&quot; class=&quot;headerlink&quot; title=&quot;Stream（流）&quot;&gt;&lt;/a&gt;Stream（流）&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Java8" scheme="https://iamlinguo.github.io/categories/Java8/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-装饰模式</title>
    <link href="https://iamlinguo.github.io/2020/09/10/DecoratorPattern/"/>
    <id>https://iamlinguo.github.io/2020/09/10/DecoratorPattern/</id>
    <published>2020-09-09T18:02:37.182Z</published>
    <updated>2020-09-09T18:09:51.154Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-09-10 01:00。<br>今天要学的设计模式是：装饰模式</p><hr><h1 id="装饰-Decorator-模式"><a href="#装饰-Decorator-模式" class="headerlink" title="装饰(Decorator)模式"></a>装饰(Decorator)模式</h1><p>站在巨人的肩上，也不容易啊！<br>今天这个装饰者模式，废了不少脑筋，一度怀疑自己的iq多低，还好，想不通就慢慢想<br>时间多得是。 </p><hr><h3 id="什么是装饰者模式？"><a href="#什么是装饰者模式？" class="headerlink" title="什么是装饰者模式？"></a>什么是装饰者模式？</h3><p>对于刚刚学完的我，对它的理解是这样的，装饰者嘛，拿古代皇帝举一个例子，<br>皇帝的生活是什么样的，饭来张口衣来伸手，一招手便有太监知道皇帝要穿衣服了，佣人们<br>早已备好衣物，佣人1为皇上穿上带super的小裤衩，佣人2为皇上穿上了它最爱的带着超级女战士的小背心，经过一番梳妆打扮，皇上这才开始用膳。其实装饰者不然，就是对一个具体的对象<br>进行一些加工，不分先后顺序也不管他好看不好看的，你想如何装饰，全凭你的想象。<br>咳咳，书上是这么说的【动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活】，装饰者实际上就是对一个对象的引用进行传递，也不能叫传递把，大概意思就是<br>对原对象添加一个新职责后，将这个已经使用过的对象作为原对象。<br>拿穿衣服这个例子来说，我要给皇上穿背心，毛衣，毛衣+1，羽绒服，秋裤，破洞牛仔裤，<br>再套一个super裤衩，完美！<br>如果按照面向对象的特征去编写这样一个穿衣服的代码，是不是每件衣服或裤子都可能会被抽象成<br>一个类，需要穿什么的时候，给对应的对象增加（穿）上去，那你的代码一定会是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 对象：皇上</span><br><span class="line"> 皇上衣服：背心，毛衣，毛衣+<span class="number">1</span>，羽绒服</span><br><span class="line"> 皇上裤子：秋裤，破洞牛仔裤</span><br><span class="line"> 皇上裤子：没有</span><br><span class="line"> Emperor emp = <span class="keyword">new</span> Emperor();  <span class="comment">// 代指皇上这个对象</span></span><br><span class="line"> Clothes clo = <span class="keyword">new</span> Clothes(); <span class="comment">// 衣服类</span></span><br><span class="line"> erp.衣服 = erp.衣服 + clo .背心; <span class="comment">//给这个对象加衣服</span></span><br><span class="line"> <span class="comment">//雷同</span></span><br><span class="line">emp.show(); <span class="comment">// result = 给皇上穿上 ...;</span></span><br></pre></td></tr></table></figure><p>结构如图：<br><img src="/images/decorator.png" alt="avatar"><br>装饰模式，对这个问题有更好的解决方案，隐藏给这个对象穿衣服的细节，实现内部组装。<br>下面就用装饰模式来实现一遍：<br>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被装饰的对象   可扩展</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linguo</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">clothes</span><span class="params">()</span></span>;   <span class="comment">//穿衣服的方法  字符串拼接</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  这个类就是装饰模式的核心，也就是之前所说的：对一个具体对象实现穿衣服</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorClothes</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Person person;    <span class="comment">//被装饰对象 == 皇上</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鞋子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoesClothes</span> <span class="keyword">extends</span> <span class="title">DecoratorClothes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShoesClothes</span> <span class="params">(Person person)</span> </span>&#123;    <span class="comment">//对象的传递就靠它了</span></span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">clothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.person.clothes() + <span class="string">"穿上鞋子"</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 短袖</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TshirtClothes</span> <span class="keyword">extends</span> <span class="title">DecoratorClothes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TshirtClothes</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">clothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.person.clothes() + <span class="string">"穿上短袖"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他雷同</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 实例对象  之前说过的，Person可扩展，这里就直接穿衣服了</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">clothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;  <span class="comment">//啥都没穿，厉害！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person = <span class="keyword">new</span> TshirtClothes(<span class="keyword">new</span> ShoeClothes(person));</span><br><span class="line">String result= <span class="string">"皇上，"</span> + person.clothes();</span><br><span class="line">System.out.println(result);</span><br><span class="line"> 结果为：<span class="string">"皇上，穿上鞋子穿上短袖"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有什么不解的地方？我起初不解的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result= <span class="string">"皇上，"</span> + person.clothes();</span><br></pre></td></tr></table></figure><p>这段代码究竟是怎么执行的，您不妨打断点进去看一下，很奇妙的哦~<br>执行这段代码的时候，会回到最初的实例化，然后根据接口的实现去执行，就会先<br>执行ShoeClothes这个类的实现，然后再执行TshirtClothes类的实现，最终实现了结果的<br>拼接。<br>所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="keyword">new</span> TshirtClothes(<span class="keyword">new</span> ShoeClothes(person));</span><br></pre></td></tr></table></figure><p>这段代码实际执行该拆分为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="keyword">new</span> ShoeClothes(person)； == 穿上衣服</span><br><span class="line"><span class="comment">// 划重点： 原对象作为新对象传递 </span></span><br><span class="line">person =  <span class="keyword">new</span> TshirtClothes(person ); == 穿上衣服 + 穿上鞋子</span><br></pre></td></tr></table></figure><p>总之就是按实例化对象的顺序执行。</p><blockquote><p>总结：<br>装饰可以实现不分顺序，随意搭配。<br>比如给皇上穿上牛仔裤再穿秋裤套个super三角裤。</p></blockquote><p>我是Linguo，生命不息，奋斗不止。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-09-10 01:00。&lt;br&gt;今天要学的设计模式是：装饰模式&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;装饰-Decorator-模式&quot;&gt;&lt;a href=&quot;#装饰-Decorator-模式&quot; class=&quot;headerlink&quot; title=&quot;装饰(Dec
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>spring开发-配置文件</title>
    <link href="https://iamlinguo.github.io/2020/09/02/springConfig/"/>
    <id>https://iamlinguo.github.io/2020/09/02/springConfig/</id>
    <published>2020-09-02T14:49:52.912Z</published>
    <updated>2020-09-02T17:10:05.860Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-09-02 22:18。<br>近期工作总结</p><hr><h1 id="spring读取配置文件"><a href="#spring读取配置文件" class="headerlink" title="spring读取配置文件"></a>spring读取配置文件</h1><p>声明：<br>.properties文件本质上和.yml文件是没区别的，只不过是写法不同，所以我们在读取的时候也没区别，所以下面说到的.properties文件你可以理解为我也在说yml文件。<br>案例文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#邮箱配置</span><br><span class="line">spring.mail.host=smtp.xxx.com</span><br><span class="line">spring.mail.username=xxx1312222874@<span class="number">163</span>.com</span><br><span class="line">spring.mail.password=xxxxpassword</span><br><span class="line">spring.mail.port=<span class="number">465</span></span><br></pre></td></tr></table></figure><p>假设我们在项目中要读取以上配置并返回到对象当中。</p><h4 id="1-使用-ConfigurationProperties"><a href="#1-使用-ConfigurationProperties" class="headerlink" title="1. 使用@ConfigurationProperties"></a>1. 使用@ConfigurationProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.mail"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Long port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<br>注解：@ConfigurationProperties(prefix = “”, value = “”, ignoreInvalidFields = true, ignoreUnknownFields = true)<br><code>ConfigurationProperties</code>主要就是用来加载我们的配置文件的，这个注解由springBoot提供，也是用的最多的。<br><code>prefix</code>：配置文件的前缀<br><code>value</code>: 和prefix作用一样，不信你看源码,跟我们的RequestMapping的path\value一样，<code>@AliasFor</code>这个注解是Spring提供的，主要是在一个类中对两个方法互为别名，但又不冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"prefix"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br></pre></td></tr></table></figure><p><code>ignoreInvalidFields</code>：忽略读取到的字段，默认false，比如有些字段会存在类型转换错误，这个时候如果不忽略那启动就会报错，如果你设置了ignoreInvalidFields = true，那如果读取到了不匹配的类型会自动忽略，防止不必要的异常，一般情况下肯定都是false，因为谁也不敢保证自己的配置就是对的<br><code>ignoreUnknownFields</code>：同样也是忽略读取到的字段，默认为true，但和<code>ignoreInvalidFields</code>是有区别的，如果读取到的配置名称找不到对应的config类的属性，则忽略，同理。</p><blockquote><p>两个忽略属性最好的区分就是一个在类型上做文章，一个在名称上做文章<br>为什么要加上<code>@Component</code>注解呢？<code>@Component</code>我们都知道，就是注册组件，将这个类注册为bean，这样我们就可以直接用<code>@Autuwired</code>进行注入，如果不注册到spring容器当中是无法使用的，在注册的过程中将配置与属性绑定上去。类似的还可以使用spring的包扫描<br>还有一个小小的提示，就是不要用new对象方式注入config对象哦~</p></blockquote><h4 id="2-使用-ConfigurationProperties-EnableConfigurationProperties"><a href="#2-使用-ConfigurationProperties-EnableConfigurationProperties" class="headerlink" title="2. 使用@ConfigurationProperties + @EnableConfigurationProperties"></a>2. 使用@ConfigurationProperties + @EnableConfigurationProperties</h4><p>刚刚也说了，如果config类只使用了<code>@ConfigurationProperties</code>，没有使用spring的提供的凡是进行注册，那这样是不生效的。<br>要说<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>的关系，就是<code>@ConfigurationProperties</code>没有自己注册时，那便要用到<code>@EnableConfigurationProperties</code>来进行注册，<br>注解2：@EnableConfigurationProperties(value = {})，value是一个泛型类<br>前提条件，这两个注解在不同的类上面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 @ConfigurationProperties 注解的config类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"wiggen.uac.provider.dingtalk"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiestest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String appKey;</span><br><span class="line">  <span class="keyword">private</span> String appSecret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 @EnableConfigurationProperties 注解的config类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; ConfigurationPropertiestest<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="comment">//springBoot 入口类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这样看，你会觉得没有多大用处，但存在即合理。</p><h4 id="3-约束配置类"><a href="#3-约束配置类" class="headerlink" title="3. 约束配置类"></a>3. 约束配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mail"</span>, name = <span class="string">"enable"</span>, matchIfMissing = <span class="keyword">false</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//配置内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果spring.mail的enable为true时则TestConfiguration生效，反之。<br>注解3：@ConditionalOnProperty(prefix = “”, name = “”, matchIfMissing = , havingValue = “”)<br><code>havingValue</code>: 给定与配置的某个属性比较是否相等，如上面的就是将<code>havingValue</code>的值与spring.mail.enable=?进行比较，如果不匹配，那么整个配置类的内容不生效。<br><code>matchIfMissing</code>：默认为false,缺少name或value指定的属性时，配置类是否生效，比如设置enable没有找到，那么配置文件就不生效，比如配置文件中没有enable这个属性，就无法进行<code>havingValue</code>的值比较，这时候就看配置的<code>matchIfMissing</code>了。<br>@ConditionalOnProperty注解是依赖@Conditional的，@Conditional的作用是根据条件判断这个类是否允许注册到容器当中的，这个有时间可以自己去研究一下。</p><p>总结：<br>现在基本上都叫不到xml的配置了，以前的项目中可能会在resource中定义很多的xml文件，但维护起来会很不方便，如果把配置写成一个类，像业务一样去处理，不仅实现了代码与xml的解耦，也提升了代码的可读性，现在基本上都将配置放在一个独立的package下面，像Service、Controller一样，当然了，随着项目的进展，配置文件的内容肯定是不小的，这就需要我们来给配置文件一些规则了，合理洽淡的运用前缀以及各种分割词、注释，阅读起来其实也很方便。</p><p>学习素材来源：实际工作</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-09-02 22:18。&lt;br&gt;近期工作总结&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;spring读取配置文件&quot;&gt;&lt;a href=&quot;#spring读取配置文件&quot; class=&quot;headerlink&quot; title=&quot;spring读取配置文件&quot;&gt;&lt;/a&gt;spr
      
    
    </summary>
    
    
      <category term="春天系列" scheme="https://iamlinguo.github.io/categories/%E6%98%A5%E5%A4%A9%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka-入门</title>
    <link href="https://iamlinguo.github.io/2020/08/29/kafkaGettingStart/"/>
    <id>https://iamlinguo.github.io/2020/08/29/kafkaGettingStart/</id>
    <published>2020-08-28T20:28:08.679Z</published>
    <updated>2020-08-28T21:58:08.409Z</updated>
    
    <content type="html"><![CDATA[<p>北京时间：2020/08/29<br>近期技术总结</p><hr><p>在学习中间件之前，我觉得最大的一个问题就在于，我们不知道中间件到底用来干嘛，经过我这几个月的工作经验，我来告诉你，中间件大部分都是应用到开发端，也就是开发人员使用，很少会将中间件应用到客户端，比如，公司需要一个任务调度中心来处理一些复杂的业务、数据统计、定时任务时，可能就需要使用消息队列来处理任务，像比较流行的kafka、RocketMQ、RabbitMQ等这类消息队列中间件。当然了，中间件并不就是指这些，它更广泛的意思大概是，【是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件】(此处copy)，像我们熟知的tomcat、数据库都可以叫做中间件。今天主要讲的是消息队列中间件Kafka。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><blockquote><ol><li>消息队列的概念<br>消息队列，如果你了解栈的特性【先进后出】，那你对消息队列的理解应该是基本上掌握了，大同小异，<br>队列【先进先出】，其实道理就跟我们平常去银行排队是一个道理，取号排队，数字有序排列，假设银行大厅允许的最大排列范围是十个人，从1-10排满，第一个人走了，11号进来排队。<br>这个概念清楚了，那就没什么难度了，无非就是对框架的掌握程度，各个消息队列框架原理一致，思路与实现不同罢了。</li><li>Kafka入门<br>为什么选择Kafka?因为分布式。<br>kafka是一个开源的消息系统，分布式消息队列，kafka对消息保存时根据topic进行归类，发送消息者称为producer,消息接受者称为consumer,此外kafka集群有多个kafka实例组成，每个实例称为broker。无论是kafka集群，还是producer和consumer都依赖于zookeeper集群保存一些meta信息，来保存系统可用性。<br>看完这个， 你只需要明白几点：<ol><li>producer (生产者) 也就是往消息队列中放入数据的人</li><li>consumer (消费者) 从消息队列中取出数据的人</li><li>我们往一个kafka实例(单个kafka服务)中放入数据时，需要指定某个topic</li><li>分布式kafka时，zoopeeper集群是基础(可以自己尝试搭建zookeeper集群)。<br>同一个时间节点一个消费者组只能有一个消费者消费，并且消费者组中消费者消费的消息不会重复。<br>消费的是某个区，比如消费者2消费了topic1下面的partition0,那么这个组的消费者1不会再去消费topic1下面的partition0。<br>消费单元：partition(区)<br>producer写的时候，同一个分区队列是有序的，不同分区的消息是无序的。<br>分区与消费者组的关系<br>我们在往一个topic下加入消息时，是放入指定的分区下的，这是一个什么概念呢，其实就类似于给topic下的消息分类，默认最少会有一个分区，一般情况下是多个分区<br>如多个消息分区<br>partition0: data1 data2<br>partition1: data3 data4<br>partition1: data5 data6 data7<br>多个消费者<br>consumer1 consumer2 consumer3<br>kafka有自己的分组策略，与之对应的也就有相应的消费策略。<br>按照默认的策略，这个时候consumer1消费的就是data1 data2 data3，consumer2消费的就是data4 data5，consumer3消费的就是data6 data7。<br>补充：默认策略2，轮询消费策略<br>其实上述也就是 <code>一对一模式</code><br>消费者组是一个什么概念呢，其实就是多个consumer被分成了组 关键字:group<br>多个消费者<br>consumer1 consumer2 consumer3 consumer4<br>consumerGroup1:consumer1 consumer2<br>consumerGroup2:consumer3 consumer4<br>这种情况下，一个分区只允许一个消费者组的一个消费者去消费，意思就是，同一个消费者组消费一个分区时，只能消费一次，但不同的消费者组可以消费同一个分区。<br>比如上面的consumerGroup1去消费partition0时，只有consumer1去消费或者consumer2消费，不能同时消费，而partition0可以被consumerGroup1、consumerGroup2消费。也就是<code>一对多模式</code><br>加深一下印象，如下图：<br><img src="/images/queue.png" alt="avatar"></li></ol></li><li>总结<br>关键字：<br>broker：kafka实例，即Kafka服务<br>topic: 主题<br>partition: 分区<br>producer: 消息生产者<br>consumer: 消息消费者<br>Kafka支持的模式：<br>点对点模式(一对一)<br>发布/订阅者模式(一对多)</li></ol></blockquote><p>学习素材来源：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;北京时间：2020/08/29&lt;br&gt;近期技术总结&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在学习中间件之前，我觉得最大的一个问题就在于，我们不知道中间件到底用来干嘛，经过我这几个月的工作经验，我来告诉你，中间件大部分都是应用到开发端，也就是开发人员使用，很少会将中间件应用到客户端，比如，
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://iamlinguo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-设计原则</title>
    <link href="https://iamlinguo.github.io/2020/06/28/designPrinciples/"/>
    <id>https://iamlinguo.github.io/2020/06/28/designPrinciples/</id>
    <published>2020-06-27T18:39:01.375Z</published>
    <updated>2020-06-27T19:05:48.507Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-06-28 02:40。<br>今天要学的的内容是：设计原则</p><hr><h1 id="设计原则（principles）"><a href="#设计原则（principles）" class="headerlink" title="设计原则（principles）"></a>设计原则（principles）</h1><blockquote><ol><li>单一职能原则<br>定义： 就一个类而言，应该仅有一个引起它变化的原因。<br>浅出： 比如前面所说的，我们在一个类中定义了加减乘数四个方法，传入一个条件可以触发其中一个操作，这就是多职能，一个类做多种事情，显然不满足单一职能，<br>所以我们把四个操作分别封装成四个不同的操作类，每个类仅负责一件事。  </li><li>开放 - 封闭原则<br>定义： 软件实体（类，模块，方法等）应该可以扩展，但是不允许修改。<br>浅出： 在我们之前的加减乘除的在一个类中时，如果某一个需求需要变更，那么我们需要去修改其中的某个方法，所以我们用接口去定义公共的方法，供每个子类去<br>实现，这样加减乘除就负责加减乘除，如果有新的需求，就继续加一个类，不对原来的代码做修改，但在原来接口的基础上做扩展。 </li><li>依赖倒置（依赖倒转）原则<br>定义：<ol><li>高层模块不依赖于底层模块，两个都应该依赖抽象。</li><li>抽象不应该依赖细节，细节应该依赖于抽象（我们应该针对接口编程，而不要对实现编程）<br>浅出：比如接口设计，父级接口一依赖子级接口，它们都应该依赖于对象，也就是父接口和子接口本身不存在依赖关系，它们依赖的来源源自<br>对一个功能的抽象所形成。  像我们的集合框架，iterator 和 list 本身不存在依赖关系，对它们的定义是对业务的抽象。</li></ol></li><li>里氏代换原则<br>定义： 子类型必须能够替换掉它们的父类型<br>浅出： 在父子接口定义以及子类实现的时候，应该满足里氏代换原则，也就是子类继承了父类后，在可以直接引用父类的的公共属性及方法时，也要能够重写父类。</li></ol></blockquote><p>学习素材来源：《大话设计模式》–程杰</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-06-28 02:40。&lt;br&gt;今天要学的的内容是：设计原则&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;设计原则（principles）&quot;&gt;&lt;a href=&quot;#设计原则（principles）&quot; class=&quot;headerlink&quot; title=&quot;设计原则（
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-策略模式</title>
    <link href="https://iamlinguo.github.io/2020/06/21/strategyPattern/"/>
    <id>https://iamlinguo.github.io/2020/06/21/strategyPattern/</id>
    <published>2020-06-21T14:16:24.056Z</published>
    <updated>2020-06-21T15:42:40.521Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-06-21 22:18。<br>今天要学的设计模式是：策略模式</p><hr><h1 id="策略-Strategy-模式"><a href="#策略-Strategy-模式" class="headerlink" title="策略(Strategy)模式"></a>策略(Strategy)模式</h1><p>策略模式，从名字不难理解，策略，就像我们平常玩游戏的策略一样，策略1，策略2，在不同模式的时候我们选择不同的策略去使用，去完成任务。<br>业务场景：收银<br>    在商场中有，我们结算的时候，可能会有打折，然后满200减20，还有正常的收费等情况。<br>如果不使用设计模式，我们第一想到的肯定还是使用条件分支去判断它，然后去实现具体的计算方式，如果学了简单工厂，可能会想到使用简单工厂模式去封装条件<br>判断，然后根据不同的条件去调用不同的实现类。这种方式是可行的，但是我们要明确知道的一点是！简单工厂只为，仅为我们解决了创建对象的问题！如果后期各<br>种计算方式发生改变，那就要每次都去维护这个工厂。 在这种情况下，选择其他设计模式可能会更优<br>策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口</span></span><br><span class="line"><span class="comment"> * 接口：对功能进行抽象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linguo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>;  <span class="comment">//收银方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略：正常收费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 86131</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashNomal</span> <span class="keyword">implements</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务代码 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略：打折</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 86131</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRebate</span> <span class="keyword">implements</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把相同功能的不同的实现策略抽出一个借口供实现。<br>策略模式重要的一个点在于，它有一个上下文的管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口的上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 86131</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CashSuper cashSuper;  <span class="comment">// 不同的实现策略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(String type)</span></span>&#123;  <span class="comment">//结合简单工厂模式  </span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"正常收费"</span>:</span><br><span class="line"><span class="keyword">this</span>.cashSuper = <span class="keyword">new</span> CashNomal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"打折"</span>:</span><br><span class="line"><span class="keyword">this</span>.cashSuper = <span class="keyword">new</span> CashRebate();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略的计算结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cashSuper.acceptCash(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上下文初始化的时候，我们结合了简单工厂，根据不同的类型实例化不同的对象。<br>居然我们选择了策略模式，那就一定有它的优点<br>比较： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂  </span></span><br><span class="line">CashSuper cashSuper = CashFactory.create(<span class="string">"类型"</span>);</span><br><span class="line"><span class="comment">//策略模式</span></span><br><span class="line">CashContext cashContext = <span class="keyword">new</span> CashContext(<span class="string">"类型"</span>);</span><br></pre></td></tr></table></figure><p>你发现了什么，是不是我们使用简单工厂的时候我们看到了CashSuper和CashFactory，而使用策略模式时只用到了上下文对象CashContext。<br>这个点就非常重要了，这说明是用策略模式的耦合度更低了，连CashSuper这个父类都看不到了。<br>总结：  </p><blockquote><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种<br>算法类与使用算法类之间的耦合。<br>策略模式的Stategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。在所有策略中，我们得到的各个功能是？<br>getResult(),获得计算费用的结果。<br>策略模式封装了变化，我们在引用的时候不需要关注策略的实现，只需要使用上下文！</p></blockquote><p>学习素材来源：《大话设计模式》–程杰</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-06-21 22:18。&lt;br&gt;今天要学的设计模式是：策略模式&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;策略-Strategy-模式&quot;&gt;&lt;a href=&quot;#策略-Strategy-模式&quot; class=&quot;headerlink&quot; title=&quot;策略(Strat
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>重学设计模式-简单工厂</title>
    <link href="https://iamlinguo.github.io/2020/06/11/simpleFactoryPattern/"/>
    <id>https://iamlinguo.github.io/2020/06/11/simpleFactoryPattern/</id>
    <published>2020-06-10T16:15:54.758Z</published>
    <updated>2020-06-10T16:30:48.041Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2020-06-10 22:30，今天星期三，哈哈最近在看的一部动漫“篮球少年王”更新了，我已经迫不及待了，先忍忍，容我写完这篇笔记。</p><p>简单的做一下今天工作的总结，早上出门下了点小雨，不过还好，因为！我带伞了哈哈哈哈，今天的工作内容主要还是改代码修代码，cto给我做的一个短信接口挑出了不少毛病，很多隐藏的bug，教我如何把代码抽离控制器实现业务层的封装，上午一直在做一个昨天没做完的图片接口，下午看了会同时刘哥写的代码，准备对接明天的任务。</p><p>最近在看“大话设计模式”这本书，今天的内容就写一下前几天看的内容把 </p><hr><h4 id="1-我为什么要学？"><a href="#1-我为什么要学？" class="headerlink" title="1. 我为什么要学？"></a>1. 我为什么要学？</h4><p>有没有一天，你突然觉得自己基础很差劲，在学校也没有好好学，工作也只会所谓的CV大法，看着复杂的项目不知从何下手，你是否听过一句话叫<code>“基础不牢，地动山摇“</code>。没错，这就是我，现在的我，从培训机构出来，感觉时间很快很匆忙就把一堆框架学完了，也写了很多代码，可还是对阅读代码、特别是开源代码库感到非常吃力，所以这也是我学习的决心，我要把没学过的东西都补回来。<br>可是每次下定决心打算学习一个知识点，三天打鱼两天晒网终究没学到什么东西，学了忘忘了学，反反复复总结：没学到啥jb。(废话好像有点多了…)<br>设计模式，我们任何一门语言好像都曾听闻过它的强大，它的好处，可我们一直停留在了对它的印象，其实不如静下心来好好学一学，相信一定收获颇丰。<br>设计模式从字面意思很好理解，设计！就这两个字足够你理解它，何为设计，设计不就是把一样不太完美的东西，经过你的一番修饰，让它变得完美。代码亦是如此，我们在工作中写了不知道多少冗余、复杂、流水代码，以至于隔三日定当不相识(????这tm是我写的代码黑人???三连)，想象一下，如果公司某个核心开源框架的底层是如此，那..后期可能会是一场灾难，这也是现在公司为什么不推崇faxxJson的一大原因(虽然易用，但bug居多，不宜长期打算，我不是黑粉！！)，设计模式我觉得最为重要的的一点莫过于这两点：<code>可复用、易读</code>。</p><h4 id="2-我学了设计模式能干嘛？"><a href="#2-我学了设计模式能干嘛？" class="headerlink" title="2. 我学了设计模式能干嘛？"></a>2. 我学了设计模式能干嘛？</h4><p>能干嘛？这tm还用想，刚刚不是说了嘛，基础差、看不懂！我不喜欢什么大道理，我就是看不懂(底子差)，我想先从设计模式入手，一步一步进阶。<br>我是一个有理想的码农，我希望某一天我也能写一款自己的开源项目给别人使用，讲实在的，能干嘛？举个例子，我现在每天写的代码，一个Method300+的代码，大量的if、else、for，在以前，我是没有意识去修改它的，项目嘛！能跑就行，有bug后期再改，其实这样是很不对的，天天CV上班摸鱼，三年下来还是老样子，更别提什么新技术新框架的掌握了，像这种大量的冗余代码的时候，大可仔细思考，那部分的代码可以抽出来形成单独的接口，在没看设计模式这本书之前，我是没有这种思想觉悟的，多学习积累经验嘛。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式这是我看的第一个设计模式，也是每一个想学习设计模式人的入门级知识，其实我目前也只学习了这一种哈哈哈哈。<br>请看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num1,num2,result; </span><br><span class="line">String symbol; <span class="comment">//符号</span></span><br><span class="line">System.out.println(<span class="string">"输入第一个数字"</span>);</span><br><span class="line">num1 = in.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入第二个数字"</span>);</span><br><span class="line">num1 = in.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入一个运算符"</span>);</span><br><span class="line">symbol = in.next(); </span><br><span class="line"><span class="keyword">if</span>(<span class="string">"+"</span>.equals(symbol))&#123;</span><br><span class="line">    result = num1 + num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(symbol))&#123;</span><br><span class="line">    result = num1 - num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(symbol))&#123;</span><br><span class="line">    result = num1 * num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(symbol))&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    result = num1 / num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看着是没有什么问题得把，如果实现了功能你是会去想如何扩展呢？还是直接push。</p><blockquote><p>Q1:  如果有1000种运算方法，怎么办？<br>    An: CV</p></blockquote><blockquote><p>Q2:  如果多个业务需要调用其中一个方法，怎么办？<br>    An: again</p></blockquote><p>问题还有很多，这两个可能是我们可能听闻过的，其实很简单，请看以下分解：<br>num1,num2,result;这三个变量实际上是固定的，所以我们把它封装到一个对象里面： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="comment">//计算需要的数值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> Number1;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> Number2;</span><br><span class="line"><span class="comment">// get set方法 </span></span><br><span class="line"><span class="comment">//返回结果的方法  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们是否可以把每个操作看做一个对象，比如加法，这个对象只做只做加法运算，减法只做减法运算,运算的对象来自哪？就是我们刚刚定义的<code>Operation</code>对象。<br>比如把加减乘除运算符拆分成四个对象，并且继承自需要运算的对象： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getNumber1() + <span class="keyword">super</span>.getNumber2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getNumber1() * <span class="keyword">super</span>.getNumber2(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他操作雷同</span></span><br></pre></td></tr></table></figure><p>重点来了！<br>什么是工厂，我第一意识就是想到了打工的工厂，不同的环节形成了工厂的流水线作业，假如我在一家做饼的工厂的新人，我负责的工作是和面粉，同事1负责的是烧饼，同事2负责的是打包。当我每天上班走到我的岗位的时候，经过了同事2打包的地方，我继续走，因为这不是我的岗位，经过同事1的时候，发现还不是，知道走到二楼，我才找到了我的岗位位置，开始一天的工作。(我实在想不出什么好的例子了)，我们的工厂模式其实也差不多：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operationType)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"+"</span>.equals(operationType))&#123;  <span class="comment">//同事2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(operationType))&#123;  <span class="comment">//同事1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(operationType))&#123;  <span class="comment">//我</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(operationType))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现一个特点，就是这个工厂对象里面包含了所有我需要的运算对象，我想要进行某一个运算的时候，直接去这个对象中拿就行了(就像我和我的同事们都被限制在这家工厂中)，当然需要给定你的条件(operationType)</p><p>今天的笔记就到这里。</p><ul><li><a href="https://iamlinguo.github.io/">iamlinguo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2020-06-10 22:30，今天星期三，哈哈最近在看的一部动漫“篮球少年王”更新了，我已经迫不及待了，先忍忍，容我写完这篇笔记。&lt;/p&gt;
&lt;p&gt;简单的做一下今天工作的总结，早上出门下了点小雨，不过还好，因为！我带伞了哈哈哈哈，今天的工作内容主要还是改代码
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://iamlinguo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>我拥有自己的blog了！</title>
    <link href="https://iamlinguo.github.io/2020/06/04/myblog/"/>
    <id>https://iamlinguo.github.io/2020/06/04/myblog/</id>
    <published>2020-06-03T18:31:43.518Z</published>
    <updated>2020-06-07T15:18:27.116Z</updated>
    
    <content type="html"><![CDATA[<p>其实之前自己写过一个blog,但是感觉不太好用，所以chrome了一下，发现很多人都在用这个HEXO的静态博客，效果还不错，<br>刚好解决了我的燃眉之急，让我快速短时间的有一个总结的地方，顺便做做技术分享。<br>我一直讲的一句话就是，“生活需要仪式感”。<br>学习，亦是如此<br>所以此时此刻此景，我要开启属于我的生涯，我的技术生涯，我的职场生涯，去追求我所热爱的东西<br>2020-06-07<br>地点：魔都<br>加油吧，少年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实之前自己写过一个blog,但是感觉不太好用，所以chrome了一下，发现很多人都在用这个HEXO的静态博客，效果还不错，&lt;br&gt;刚好解决了我的燃眉之急，让我快速短时间的有一个总结的地方，顺便做做技术分享。&lt;br&gt;我一直讲的一句话就是，“生活需要仪式感”。&lt;br&gt;学习，亦
      
    
    </summary>
    
    
    
      <category term="初衷" scheme="https://iamlinguo.github.io/tags/%E5%88%9D%E8%A1%B7/"/>
    
  </entry>
  
</feed>
